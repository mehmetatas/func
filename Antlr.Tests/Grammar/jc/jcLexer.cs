//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 jc.g 2013-04-28 00:38:07

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 168, 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using ConditionalAttribute = System.Diagnostics.ConditionalAttribute;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class jcLexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int T__41=41;
	public const int T__42=42;
	public const int T__43=43;
	public const int T__44=44;
	public const int T__45=45;
	public const int T__46=46;
	public const int T__47=47;
	public const int ASSIGN=4;
	public const int BOOL=5;
	public const int CLOSE_BRACE=6;
	public const int CLOSE_PAR=7;
	public const int COMMA=8;
	public const int COMMENT=9;
	public const int DATE=10;
	public const int DATETIME=11;
	public const int DATE_FRAG=12;
	public const int DAY=13;
	public const int DIGIT=14;
	public const int DIV=15;
	public const int DOT=16;
	public const int HOUR=17;
	public const int IDENT=18;
	public const int LETTER=19;
	public const int MILLISECOND=20;
	public const int MINUS=21;
	public const int MINUTE=22;
	public const int MOD=23;
	public const int MONTH=24;
	public const int MUL=25;
	public const int MULTILINE_COMMENT=26;
	public const int NAME=27;
	public const int NUMBER=28;
	public const int OPEN_BRACE=29;
	public const int OPEN_PAR=30;
	public const int PATH=31;
	public const int PLUS=32;
	public const int SECOND=33;
	public const int SEMICOL=34;
	public const int STRING=35;
	public const int TIME=36;
	public const int TIME_FRAG=37;
	public const int TYPE=38;
	public const int WS=39;
	public const int YEAR=40;

    // delegates
    // delegators

	public jcLexer()
	{
		OnCreated();
	}

	public jcLexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	public jcLexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
	public override string GrammarFileName { get { return "jc.g"; } }

	private static readonly bool[] decisionCanBacktrack = new bool[0];

	[Conditional("ANTLR_TRACE")]
	protected virtual void OnCreated() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule(string ruleName, int ruleIndex) {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule(string ruleName, int ruleIndex) {}

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_T__41() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_T__41() {}

    // $ANTLR start "T__41"
    [GrammarRule("T__41")]
    private void mT__41()
    {
    	EnterRule_T__41();
    	EnterRule("T__41", 1);
    	TraceIn("T__41", 1);
    		try
    		{
    		int _type = T__41;
    		int _channel = DefaultTokenChannel;
    		// jc.g:7:7: ( ':' )
    		DebugEnterAlt(1);
    		// jc.g:7:9: ':'
    		{
    		DebugLocation(7, 9);
    		Match(':'); if (state.failed) return;

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("T__41", 1);
    		LeaveRule("T__41", 1);
    		LeaveRule_T__41();
        }
    }
    // $ANTLR end "T__41"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_T__42() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_T__42() {}

    // $ANTLR start "T__42"
    [GrammarRule("T__42")]
    private void mT__42()
    {
    	EnterRule_T__42();
    	EnterRule("T__42", 2);
    	TraceIn("T__42", 2);
    		try
    		{
    		int _type = T__42;
    		int _channel = DefaultTokenChannel;
    		// jc.g:8:7: ( 'function' )
    		DebugEnterAlt(1);
    		// jc.g:8:9: 'function'
    		{
    		DebugLocation(8, 9);
    		Match("function"); if (state.failed) return;


    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("T__42", 2);
    		LeaveRule("T__42", 2);
    		LeaveRule_T__42();
        }
    }
    // $ANTLR end "T__42"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_T__43() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_T__43() {}

    // $ANTLR start "T__43"
    [GrammarRule("T__43")]
    private void mT__43()
    {
    	EnterRule_T__43();
    	EnterRule("T__43", 3);
    	TraceIn("T__43", 3);
    		try
    		{
    		int _type = T__43;
    		int _channel = DefaultTokenChannel;
    		// jc.g:9:7: ( 'get' )
    		DebugEnterAlt(1);
    		// jc.g:9:9: 'get'
    		{
    		DebugLocation(9, 9);
    		Match("get"); if (state.failed) return;


    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("T__43", 3);
    		LeaveRule("T__43", 3);
    		LeaveRule_T__43();
        }
    }
    // $ANTLR end "T__43"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_T__44() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_T__44() {}

    // $ANTLR start "T__44"
    [GrammarRule("T__44")]
    private void mT__44()
    {
    	EnterRule_T__44();
    	EnterRule("T__44", 4);
    	TraceIn("T__44", 4);
    		try
    		{
    		int _type = T__44;
    		int _channel = DefaultTokenChannel;
    		// jc.g:10:7: ( 'if' )
    		DebugEnterAlt(1);
    		// jc.g:10:9: 'if'
    		{
    		DebugLocation(10, 9);
    		Match("if"); if (state.failed) return;


    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("T__44", 4);
    		LeaveRule("T__44", 4);
    		LeaveRule_T__44();
        }
    }
    // $ANTLR end "T__44"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_T__45() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_T__45() {}

    // $ANTLR start "T__45"
    [GrammarRule("T__45")]
    private void mT__45()
    {
    	EnterRule_T__45();
    	EnterRule("T__45", 5);
    	TraceIn("T__45", 5);
    		try
    		{
    		int _type = T__45;
    		int _channel = DefaultTokenChannel;
    		// jc.g:11:7: ( 'return' )
    		DebugEnterAlt(1);
    		// jc.g:11:9: 'return'
    		{
    		DebugLocation(11, 9);
    		Match("return"); if (state.failed) return;


    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("T__45", 5);
    		LeaveRule("T__45", 5);
    		LeaveRule_T__45();
        }
    }
    // $ANTLR end "T__45"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_T__46() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_T__46() {}

    // $ANTLR start "T__46"
    [GrammarRule("T__46")]
    private void mT__46()
    {
    	EnterRule_T__46();
    	EnterRule("T__46", 6);
    	TraceIn("T__46", 6);
    		try
    		{
    		int _type = T__46;
    		int _channel = DefaultTokenChannel;
    		// jc.g:12:7: ( 'set' )
    		DebugEnterAlt(1);
    		// jc.g:12:9: 'set'
    		{
    		DebugLocation(12, 9);
    		Match("set"); if (state.failed) return;


    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("T__46", 6);
    		LeaveRule("T__46", 6);
    		LeaveRule_T__46();
        }
    }
    // $ANTLR end "T__46"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_T__47() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_T__47() {}

    // $ANTLR start "T__47"
    [GrammarRule("T__47")]
    private void mT__47()
    {
    	EnterRule_T__47();
    	EnterRule("T__47", 7);
    	TraceIn("T__47", 7);
    		try
    		{
    		int _type = T__47;
    		int _channel = DefaultTokenChannel;
    		// jc.g:13:7: ( 'var' )
    		DebugEnterAlt(1);
    		// jc.g:13:9: 'var'
    		{
    		DebugLocation(13, 9);
    		Match("var"); if (state.failed) return;


    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("T__47", 7);
    		LeaveRule("T__47", 7);
    		LeaveRule_T__47();
        }
    }
    // $ANTLR end "T__47"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_TYPE() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_TYPE() {}

    // $ANTLR start "TYPE"
    [GrammarRule("TYPE")]
    private void mTYPE()
    {
    	EnterRule_TYPE();
    	EnterRule("TYPE", 8);
    	TraceIn("TYPE", 8);
    		try
    		{
    		int _type = TYPE;
    		int _channel = DefaultTokenChannel;
    		// jc.g:90:2: ( 'string' | 'number' | 'bool' | 'date' | 'time' | 'datetime' )
    		int alt1=6;
    		try { DebugEnterDecision(1, decisionCanBacktrack[1]);
    		switch (input.LA(1))
    		{
    		case 's':
    			{
    			alt1 = 1;
    			}
    			break;
    		case 'n':
    			{
    			alt1 = 2;
    			}
    			break;
    		case 'b':
    			{
    			alt1 = 3;
    			}
    			break;
    		case 'd':
    			{
    			int LA1_4 = input.LA(2);

    			if ((LA1_4=='a'))
    			{
    				int LA1_6 = input.LA(3);

    				if ((LA1_6=='t'))
    				{
    					int LA1_7 = input.LA(4);

    					if ((LA1_7=='e'))
    					{
    						int LA1_8 = input.LA(5);

    						if ((LA1_8=='t'))
    						{
    							alt1 = 6;
    						}
    						else
    						{
    							alt1 = 4;
    						}
    					}
    					else
    					{
    						if (state.backtracking>0) {state.failed=true; return;}
    						NoViableAltException nvae = new NoViableAltException("", 1, 7, input);
    						DebugRecognitionException(nvae);
    						throw nvae;
    					}
    				}
    				else
    				{
    					if (state.backtracking>0) {state.failed=true; return;}
    					NoViableAltException nvae = new NoViableAltException("", 1, 6, input);
    					DebugRecognitionException(nvae);
    					throw nvae;
    				}
    			}
    			else
    			{
    				if (state.backtracking>0) {state.failed=true; return;}
    				NoViableAltException nvae = new NoViableAltException("", 1, 4, input);
    				DebugRecognitionException(nvae);
    				throw nvae;
    			}
    			}
    			break;
    		case 't':
    			{
    			alt1 = 5;
    			}
    			break;
    		default:
    			{
    				if (state.backtracking>0) {state.failed=true; return;}
    				NoViableAltException nvae = new NoViableAltException("", 1, 0, input);
    				DebugRecognitionException(nvae);
    				throw nvae;
    			}
    		}

    		} finally { DebugExitDecision(1); }
    		switch (alt1)
    		{
    		case 1:
    			DebugEnterAlt(1);
    			// jc.g:90:4: 'string'
    			{
    			DebugLocation(90, 4);
    			Match("string"); if (state.failed) return;


    			}
    			break;
    		case 2:
    			DebugEnterAlt(2);
    			// jc.g:91:4: 'number'
    			{
    			DebugLocation(91, 4);
    			Match("number"); if (state.failed) return;


    			}
    			break;
    		case 3:
    			DebugEnterAlt(3);
    			// jc.g:92:4: 'bool'
    			{
    			DebugLocation(92, 4);
    			Match("bool"); if (state.failed) return;


    			}
    			break;
    		case 4:
    			DebugEnterAlt(4);
    			// jc.g:93:4: 'date'
    			{
    			DebugLocation(93, 4);
    			Match("date"); if (state.failed) return;


    			}
    			break;
    		case 5:
    			DebugEnterAlt(5);
    			// jc.g:94:4: 'time'
    			{
    			DebugLocation(94, 4);
    			Match("time"); if (state.failed) return;


    			}
    			break;
    		case 6:
    			DebugEnterAlt(6);
    			// jc.g:95:4: 'datetime'
    			{
    			DebugLocation(95, 4);
    			Match("datetime"); if (state.failed) return;


    			}
    			break;

    		}
    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("TYPE", 8);
    		LeaveRule("TYPE", 8);
    		LeaveRule_TYPE();
        }
    }
    // $ANTLR end "TYPE"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_LETTER() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_LETTER() {}

    // $ANTLR start "LETTER"
    [GrammarRule("LETTER")]
    private void mLETTER()
    {
    	EnterRule_LETTER();
    	EnterRule("LETTER", 9);
    	TraceIn("LETTER", 9);
    		try
    		{
    		// jc.g:98:17: ( ( 'a' .. 'z' | 'A' .. 'Z' ) )
    		DebugEnterAlt(1);
    		// jc.g:
    		{
    		DebugLocation(98, 17);
    		if ((input.LA(1)>='A' && input.LA(1)<='Z')||(input.LA(1)>='a' && input.LA(1)<='z'))
    		{
    			input.Consume();
    		state.failed=false;
    		}
    		else
    		{
    			if (state.backtracking>0) {state.failed=true; return;}
    			MismatchedSetException mse = new MismatchedSetException(null,input);
    			DebugRecognitionException(mse);
    			Recover(mse);
    			throw mse;
    		}


    		}

    	}
    	finally
    	{
    		TraceOut("LETTER", 9);
    		LeaveRule("LETTER", 9);
    		LeaveRule_LETTER();
        }
    }
    // $ANTLR end "LETTER"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_DIGIT() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_DIGIT() {}

    // $ANTLR start "DIGIT"
    [GrammarRule("DIGIT")]
    private void mDIGIT()
    {
    	EnterRule_DIGIT();
    	EnterRule("DIGIT", 10);
    	TraceIn("DIGIT", 10);
    		try
    		{
    		// jc.g:99:16: ( '0' .. '9' )
    		DebugEnterAlt(1);
    		// jc.g:
    		{
    		DebugLocation(99, 16);
    		if ((input.LA(1)>='0' && input.LA(1)<='9'))
    		{
    			input.Consume();
    		state.failed=false;
    		}
    		else
    		{
    			if (state.backtracking>0) {state.failed=true; return;}
    			MismatchedSetException mse = new MismatchedSetException(null,input);
    			DebugRecognitionException(mse);
    			Recover(mse);
    			throw mse;
    		}


    		}

    	}
    	finally
    	{
    		TraceOut("DIGIT", 10);
    		LeaveRule("DIGIT", 10);
    		LeaveRule_DIGIT();
        }
    }
    // $ANTLR end "DIGIT"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_IDENT() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_IDENT() {}

    // $ANTLR start "IDENT"
    [GrammarRule("IDENT")]
    private void mIDENT()
    {
    	EnterRule_IDENT();
    	EnterRule("IDENT", 11);
    	TraceIn("IDENT", 11);
    		try
    		{
    		// jc.g:100:16: ( LETTER ( LETTER | DIGIT )* )
    		DebugEnterAlt(1);
    		// jc.g:100:18: LETTER ( LETTER | DIGIT )*
    		{
    		DebugLocation(100, 18);
    		mLETTER(); if (state.failed) return;
    		DebugLocation(100, 25);
    		// jc.g:100:25: ( LETTER | DIGIT )*
    		try { DebugEnterSubRule(2);
    		while (true)
    		{
    			int alt2=2;
    			try { DebugEnterDecision(2, decisionCanBacktrack[2]);
    			int LA2_0 = input.LA(1);

    			if (((LA2_0>='0' && LA2_0<='9')||(LA2_0>='A' && LA2_0<='Z')||(LA2_0>='a' && LA2_0<='z')))
    			{
    				alt2 = 1;
    			}


    			} finally { DebugExitDecision(2); }
    			switch ( alt2 )
    			{
    			case 1:
    				DebugEnterAlt(1);
    				// jc.g:
    				{
    				DebugLocation(100, 25);
    				input.Consume();
    				state.failed=false;

    				}
    				break;

    			default:
    				goto loop2;
    			}
    		}

    		loop2:
    			;

    		} finally { DebugExitSubRule(2); }


    		}

    	}
    	finally
    	{
    		TraceOut("IDENT", 11);
    		LeaveRule("IDENT", 11);
    		LeaveRule_IDENT();
        }
    }
    // $ANTLR end "IDENT"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_YEAR() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_YEAR() {}

    // $ANTLR start "YEAR"
    [GrammarRule("YEAR")]
    private void mYEAR()
    {
    	EnterRule_YEAR();
    	EnterRule("YEAR", 12);
    	TraceIn("YEAR", 12);
    		try
    		{
    		// jc.g:102:15: ( DIGIT DIGIT DIGIT DIGIT )
    		DebugEnterAlt(1);
    		// jc.g:102:19: DIGIT DIGIT DIGIT DIGIT
    		{
    		DebugLocation(102, 19);
    		mDIGIT(); if (state.failed) return;
    		DebugLocation(102, 25);
    		mDIGIT(); if (state.failed) return;
    		DebugLocation(102, 31);
    		mDIGIT(); if (state.failed) return;
    		DebugLocation(102, 37);
    		mDIGIT(); if (state.failed) return;

    		}

    	}
    	finally
    	{
    		TraceOut("YEAR", 12);
    		LeaveRule("YEAR", 12);
    		LeaveRule_YEAR();
        }
    }
    // $ANTLR end "YEAR"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_MONTH() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_MONTH() {}

    // $ANTLR start "MONTH"
    [GrammarRule("MONTH")]
    private void mMONTH()
    {
    	EnterRule_MONTH();
    	EnterRule("MONTH", 13);
    	TraceIn("MONTH", 13);
    		try
    		{
    		// jc.g:103:16: ( DIGIT DIGIT )
    		DebugEnterAlt(1);
    		// jc.g:103:19: DIGIT DIGIT
    		{
    		DebugLocation(103, 19);
    		mDIGIT(); if (state.failed) return;
    		DebugLocation(103, 25);
    		mDIGIT(); if (state.failed) return;

    		}

    	}
    	finally
    	{
    		TraceOut("MONTH", 13);
    		LeaveRule("MONTH", 13);
    		LeaveRule_MONTH();
        }
    }
    // $ANTLR end "MONTH"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_DAY() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_DAY() {}

    // $ANTLR start "DAY"
    [GrammarRule("DAY")]
    private void mDAY()
    {
    	EnterRule_DAY();
    	EnterRule("DAY", 14);
    	TraceIn("DAY", 14);
    		try
    		{
    		// jc.g:104:14: ( DIGIT DIGIT )
    		DebugEnterAlt(1);
    		// jc.g:104:18: DIGIT DIGIT
    		{
    		DebugLocation(104, 18);
    		mDIGIT(); if (state.failed) return;
    		DebugLocation(104, 24);
    		mDIGIT(); if (state.failed) return;

    		}

    	}
    	finally
    	{
    		TraceOut("DAY", 14);
    		LeaveRule("DAY", 14);
    		LeaveRule_DAY();
        }
    }
    // $ANTLR end "DAY"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_HOUR() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_HOUR() {}

    // $ANTLR start "HOUR"
    [GrammarRule("HOUR")]
    private void mHOUR()
    {
    	EnterRule_HOUR();
    	EnterRule("HOUR", 15);
    	TraceIn("HOUR", 15);
    		try
    		{
    		// jc.g:105:15: ( DIGIT DIGIT )
    		DebugEnterAlt(1);
    		// jc.g:105:19: DIGIT DIGIT
    		{
    		DebugLocation(105, 19);
    		mDIGIT(); if (state.failed) return;
    		DebugLocation(105, 25);
    		mDIGIT(); if (state.failed) return;

    		}

    	}
    	finally
    	{
    		TraceOut("HOUR", 15);
    		LeaveRule("HOUR", 15);
    		LeaveRule_HOUR();
        }
    }
    // $ANTLR end "HOUR"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_MINUTE() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_MINUTE() {}

    // $ANTLR start "MINUTE"
    [GrammarRule("MINUTE")]
    private void mMINUTE()
    {
    	EnterRule_MINUTE();
    	EnterRule("MINUTE", 16);
    	TraceIn("MINUTE", 16);
    		try
    		{
    		// jc.g:106:17: ( DIGIT DIGIT )
    		DebugEnterAlt(1);
    		// jc.g:106:20: DIGIT DIGIT
    		{
    		DebugLocation(106, 20);
    		mDIGIT(); if (state.failed) return;
    		DebugLocation(106, 26);
    		mDIGIT(); if (state.failed) return;

    		}

    	}
    	finally
    	{
    		TraceOut("MINUTE", 16);
    		LeaveRule("MINUTE", 16);
    		LeaveRule_MINUTE();
        }
    }
    // $ANTLR end "MINUTE"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_SECOND() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_SECOND() {}

    // $ANTLR start "SECOND"
    [GrammarRule("SECOND")]
    private void mSECOND()
    {
    	EnterRule_SECOND();
    	EnterRule("SECOND", 17);
    	TraceIn("SECOND", 17);
    		try
    		{
    		// jc.g:107:17: ( DIGIT DIGIT )
    		DebugEnterAlt(1);
    		// jc.g:107:20: DIGIT DIGIT
    		{
    		DebugLocation(107, 20);
    		mDIGIT(); if (state.failed) return;
    		DebugLocation(107, 26);
    		mDIGIT(); if (state.failed) return;

    		}

    	}
    	finally
    	{
    		TraceOut("SECOND", 17);
    		LeaveRule("SECOND", 17);
    		LeaveRule_SECOND();
        }
    }
    // $ANTLR end "SECOND"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_MILLISECOND() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_MILLISECOND() {}

    // $ANTLR start "MILLISECOND"
    [GrammarRule("MILLISECOND")]
    private void mMILLISECOND()
    {
    	EnterRule_MILLISECOND();
    	EnterRule("MILLISECOND", 18);
    	TraceIn("MILLISECOND", 18);
    		try
    		{
    		// jc.g:108:22: ( DIGIT DIGIT DIGIT )
    		DebugEnterAlt(1);
    		// jc.g:108:24: DIGIT DIGIT DIGIT
    		{
    		DebugLocation(108, 24);
    		mDIGIT(); if (state.failed) return;
    		DebugLocation(108, 30);
    		mDIGIT(); if (state.failed) return;
    		DebugLocation(108, 36);
    		mDIGIT(); if (state.failed) return;

    		}

    	}
    	finally
    	{
    		TraceOut("MILLISECOND", 18);
    		LeaveRule("MILLISECOND", 18);
    		LeaveRule_MILLISECOND();
        }
    }
    // $ANTLR end "MILLISECOND"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_DATE_FRAG() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_DATE_FRAG() {}

    // $ANTLR start "DATE_FRAG"
    [GrammarRule("DATE_FRAG")]
    private void mDATE_FRAG()
    {
    	EnterRule_DATE_FRAG();
    	EnterRule("DATE_FRAG", 19);
    	TraceIn("DATE_FRAG", 19);
    		try
    		{
    		// jc.g:110:20: ( YEAR '-' MONTH '-' DAY )
    		DebugEnterAlt(1);
    		// jc.g:110:22: YEAR '-' MONTH '-' DAY
    		{
    		DebugLocation(110, 22);
    		mYEAR(); if (state.failed) return;
    		DebugLocation(110, 27);
    		Match('-'); if (state.failed) return;
    		DebugLocation(110, 31);
    		mMONTH(); if (state.failed) return;
    		DebugLocation(110, 37);
    		Match('-'); if (state.failed) return;
    		DebugLocation(110, 41);
    		mDAY(); if (state.failed) return;

    		}

    	}
    	finally
    	{
    		TraceOut("DATE_FRAG", 19);
    		LeaveRule("DATE_FRAG", 19);
    		LeaveRule_DATE_FRAG();
        }
    }
    // $ANTLR end "DATE_FRAG"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_TIME_FRAG() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_TIME_FRAG() {}

    // $ANTLR start "TIME_FRAG"
    [GrammarRule("TIME_FRAG")]
    private void mTIME_FRAG()
    {
    	EnterRule_TIME_FRAG();
    	EnterRule("TIME_FRAG", 20);
    	TraceIn("TIME_FRAG", 20);
    		try
    		{
    		// jc.g:111:20: ( HOUR ':' MINUTE ':' SECOND ( '.' MILLISECOND )? )
    		DebugEnterAlt(1);
    		// jc.g:111:22: HOUR ':' MINUTE ':' SECOND ( '.' MILLISECOND )?
    		{
    		DebugLocation(111, 22);
    		mHOUR(); if (state.failed) return;
    		DebugLocation(111, 27);
    		Match(':'); if (state.failed) return;
    		DebugLocation(111, 31);
    		mMINUTE(); if (state.failed) return;
    		DebugLocation(111, 38);
    		Match(':'); if (state.failed) return;
    		DebugLocation(111, 42);
    		mSECOND(); if (state.failed) return;
    		DebugLocation(111, 49);
    		// jc.g:111:49: ( '.' MILLISECOND )?
    		int alt3=2;
    		try { DebugEnterSubRule(3);
    		try { DebugEnterDecision(3, decisionCanBacktrack[3]);
    		int LA3_0 = input.LA(1);

    		if ((LA3_0=='.'))
    		{
    			alt3 = 1;
    		}
    		} finally { DebugExitDecision(3); }
    		switch (alt3)
    		{
    		case 1:
    			DebugEnterAlt(1);
    			// jc.g:111:50: '.' MILLISECOND
    			{
    			DebugLocation(111, 50);
    			Match('.'); if (state.failed) return;
    			DebugLocation(111, 54);
    			mMILLISECOND(); if (state.failed) return;

    			}
    			break;

    		}
    		} finally { DebugExitSubRule(3); }


    		}

    	}
    	finally
    	{
    		TraceOut("TIME_FRAG", 20);
    		LeaveRule("TIME_FRAG", 20);
    		LeaveRule_TIME_FRAG();
        }
    }
    // $ANTLR end "TIME_FRAG"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_PATH() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_PATH() {}

    // $ANTLR start "PATH"
    [GrammarRule("PATH")]
    private void mPATH()
    {
    	EnterRule_PATH();
    	EnterRule("PATH", 21);
    	TraceIn("PATH", 21);
    		try
    		{
    		// jc.g:113:15: ()
    		DebugEnterAlt(1);
    		// jc.g:113:17: 
    		{
    		}

    	}
    	finally
    	{
    		TraceOut("PATH", 21);
    		LeaveRule("PATH", 21);
    		LeaveRule_PATH();
        }
    }
    // $ANTLR end "PATH"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_DATETIME() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_DATETIME() {}

    // $ANTLR start "DATETIME"
    [GrammarRule("DATETIME")]
    private void mDATETIME()
    {
    	EnterRule_DATETIME();
    	EnterRule("DATETIME", 22);
    	TraceIn("DATETIME", 22);
    		try
    		{
    		// jc.g:114:19: ()
    		DebugEnterAlt(1);
    		// jc.g:114:21: 
    		{
    		}

    	}
    	finally
    	{
    		TraceOut("DATETIME", 22);
    		LeaveRule("DATETIME", 22);
    		LeaveRule_DATETIME();
        }
    }
    // $ANTLR end "DATETIME"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_BOOL() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_BOOL() {}

    // $ANTLR start "BOOL"
    [GrammarRule("BOOL")]
    private void mBOOL()
    {
    	EnterRule_BOOL();
    	EnterRule("BOOL", 23);
    	TraceIn("BOOL", 23);
    		try
    		{
    		int _type = BOOL;
    		int _channel = DefaultTokenChannel;
    		// jc.g:117:2: ( 'true' | 'false' )
    		int alt4=2;
    		try { DebugEnterDecision(4, decisionCanBacktrack[4]);
    		int LA4_0 = input.LA(1);

    		if ((LA4_0=='t'))
    		{
    			alt4 = 1;
    		}
    		else if ((LA4_0=='f'))
    		{
    			alt4 = 2;
    		}
    		else
    		{
    			if (state.backtracking>0) {state.failed=true; return;}
    			NoViableAltException nvae = new NoViableAltException("", 4, 0, input);
    			DebugRecognitionException(nvae);
    			throw nvae;
    		}
    		} finally { DebugExitDecision(4); }
    		switch (alt4)
    		{
    		case 1:
    			DebugEnterAlt(1);
    			// jc.g:117:4: 'true'
    			{
    			DebugLocation(117, 4);
    			Match("true"); if (state.failed) return;


    			}
    			break;
    		case 2:
    			DebugEnterAlt(2);
    			// jc.g:118:4: 'false'
    			{
    			DebugLocation(118, 4);
    			Match("false"); if (state.failed) return;


    			}
    			break;

    		}
    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("BOOL", 23);
    		LeaveRule("BOOL", 23);
    		LeaveRule_BOOL();
        }
    }
    // $ANTLR end "BOOL"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_NAME() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_NAME() {}

    // $ANTLR start "NAME"
    [GrammarRule("NAME")]
    private void mNAME()
    {
    	EnterRule_NAME();
    	EnterRule("NAME", 24);
    	TraceIn("NAME", 24);
    		try
    		{
    		int _type = NAME;
    		int _channel = DefaultTokenChannel;
    		// jc.g:121:6: ( IDENT ( ( '.' IDENT )=> '.' IDENT )* )
    		DebugEnterAlt(1);
    		// jc.g:121:8: IDENT ( ( '.' IDENT )=> '.' IDENT )*
    		{
    		DebugLocation(121, 8);
    		mIDENT(); if (state.failed) return;
    		DebugLocation(121, 14);
    		// jc.g:121:14: ( ( '.' IDENT )=> '.' IDENT )*
    		try { DebugEnterSubRule(5);
    		while (true)
    		{
    			int alt5=2;
    			try { DebugEnterDecision(5, decisionCanBacktrack[5]);
    			int LA5_0 = input.LA(1);

    			if ((LA5_0=='.') && (EvaluatePredicate(synpred1_jc_fragment)))
    			{
    				alt5 = 1;
    			}


    			} finally { DebugExitDecision(5); }
    			switch ( alt5 )
    			{
    			case 1:
    				DebugEnterAlt(1);
    				// jc.g:121:15: ( '.' IDENT )=> '.' IDENT
    				{
    				DebugLocation(121, 30);
    				Match('.'); if (state.failed) return;
    				DebugLocation(121, 34);
    				mIDENT(); if (state.failed) return;
    				DebugLocation(121, 40);
    				if (state.backtracking == 0)
    				{
    					_type=PATH;
    				}

    				}
    				break;

    			default:
    				goto loop5;
    			}
    		}

    		loop5:
    			;

    		} finally { DebugExitSubRule(5); }


    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("NAME", 24);
    		LeaveRule("NAME", 24);
    		LeaveRule_NAME();
        }
    }
    // $ANTLR end "NAME"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_DOT() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_DOT() {}

    // $ANTLR start "DOT"
    [GrammarRule("DOT")]
    private void mDOT()
    {
    	EnterRule_DOT();
    	EnterRule("DOT", 25);
    	TraceIn("DOT", 25);
    		try
    		{
    		int _type = DOT;
    		int _channel = DefaultTokenChannel;
    		// jc.g:123:4: ( '.' )
    		DebugEnterAlt(1);
    		// jc.g:123:6: '.'
    		{
    		DebugLocation(123, 6);
    		Match('.'); if (state.failed) return;

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("DOT", 25);
    		LeaveRule("DOT", 25);
    		LeaveRule_DOT();
        }
    }
    // $ANTLR end "DOT"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_COMMA() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_COMMA() {}

    // $ANTLR start "COMMA"
    [GrammarRule("COMMA")]
    private void mCOMMA()
    {
    	EnterRule_COMMA();
    	EnterRule("COMMA", 26);
    	TraceIn("COMMA", 26);
    		try
    		{
    		int _type = COMMA;
    		int _channel = DefaultTokenChannel;
    		// jc.g:124:7: ( ',' )
    		DebugEnterAlt(1);
    		// jc.g:124:9: ','
    		{
    		DebugLocation(124, 9);
    		Match(','); if (state.failed) return;

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("COMMA", 26);
    		LeaveRule("COMMA", 26);
    		LeaveRule_COMMA();
        }
    }
    // $ANTLR end "COMMA"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_SEMICOL() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_SEMICOL() {}

    // $ANTLR start "SEMICOL"
    [GrammarRule("SEMICOL")]
    private void mSEMICOL()
    {
    	EnterRule_SEMICOL();
    	EnterRule("SEMICOL", 27);
    	TraceIn("SEMICOL", 27);
    		try
    		{
    		int _type = SEMICOL;
    		int _channel = DefaultTokenChannel;
    		// jc.g:125:9: ( ';' )
    		DebugEnterAlt(1);
    		// jc.g:125:11: ';'
    		{
    		DebugLocation(125, 11);
    		Match(';'); if (state.failed) return;

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("SEMICOL", 27);
    		LeaveRule("SEMICOL", 27);
    		LeaveRule_SEMICOL();
        }
    }
    // $ANTLR end "SEMICOL"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_OPEN_PAR() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_OPEN_PAR() {}

    // $ANTLR start "OPEN_PAR"
    [GrammarRule("OPEN_PAR")]
    private void mOPEN_PAR()
    {
    	EnterRule_OPEN_PAR();
    	EnterRule("OPEN_PAR", 28);
    	TraceIn("OPEN_PAR", 28);
    		try
    		{
    		int _type = OPEN_PAR;
    		int _channel = DefaultTokenChannel;
    		// jc.g:126:10: ( '(' )
    		DebugEnterAlt(1);
    		// jc.g:126:12: '('
    		{
    		DebugLocation(126, 12);
    		Match('('); if (state.failed) return;

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("OPEN_PAR", 28);
    		LeaveRule("OPEN_PAR", 28);
    		LeaveRule_OPEN_PAR();
        }
    }
    // $ANTLR end "OPEN_PAR"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_CLOSE_PAR() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_CLOSE_PAR() {}

    // $ANTLR start "CLOSE_PAR"
    [GrammarRule("CLOSE_PAR")]
    private void mCLOSE_PAR()
    {
    	EnterRule_CLOSE_PAR();
    	EnterRule("CLOSE_PAR", 29);
    	TraceIn("CLOSE_PAR", 29);
    		try
    		{
    		int _type = CLOSE_PAR;
    		int _channel = DefaultTokenChannel;
    		// jc.g:127:11: ( ')' )
    		DebugEnterAlt(1);
    		// jc.g:127:13: ')'
    		{
    		DebugLocation(127, 13);
    		Match(')'); if (state.failed) return;

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("CLOSE_PAR", 29);
    		LeaveRule("CLOSE_PAR", 29);
    		LeaveRule_CLOSE_PAR();
        }
    }
    // $ANTLR end "CLOSE_PAR"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_OPEN_BRACE() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_OPEN_BRACE() {}

    // $ANTLR start "OPEN_BRACE"
    [GrammarRule("OPEN_BRACE")]
    private void mOPEN_BRACE()
    {
    	EnterRule_OPEN_BRACE();
    	EnterRule("OPEN_BRACE", 30);
    	TraceIn("OPEN_BRACE", 30);
    		try
    		{
    		int _type = OPEN_BRACE;
    		int _channel = DefaultTokenChannel;
    		// jc.g:128:12: ( '{' )
    		DebugEnterAlt(1);
    		// jc.g:128:14: '{'
    		{
    		DebugLocation(128, 14);
    		Match('{'); if (state.failed) return;

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("OPEN_BRACE", 30);
    		LeaveRule("OPEN_BRACE", 30);
    		LeaveRule_OPEN_BRACE();
        }
    }
    // $ANTLR end "OPEN_BRACE"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_CLOSE_BRACE() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_CLOSE_BRACE() {}

    // $ANTLR start "CLOSE_BRACE"
    [GrammarRule("CLOSE_BRACE")]
    private void mCLOSE_BRACE()
    {
    	EnterRule_CLOSE_BRACE();
    	EnterRule("CLOSE_BRACE", 31);
    	TraceIn("CLOSE_BRACE", 31);
    		try
    		{
    		int _type = CLOSE_BRACE;
    		int _channel = DefaultTokenChannel;
    		// jc.g:129:13: ( '}' )
    		DebugEnterAlt(1);
    		// jc.g:129:15: '}'
    		{
    		DebugLocation(129, 15);
    		Match('}'); if (state.failed) return;

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("CLOSE_BRACE", 31);
    		LeaveRule("CLOSE_BRACE", 31);
    		LeaveRule_CLOSE_BRACE();
        }
    }
    // $ANTLR end "CLOSE_BRACE"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_PLUS() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_PLUS() {}

    // $ANTLR start "PLUS"
    [GrammarRule("PLUS")]
    private void mPLUS()
    {
    	EnterRule_PLUS();
    	EnterRule("PLUS", 32);
    	TraceIn("PLUS", 32);
    		try
    		{
    		int _type = PLUS;
    		int _channel = DefaultTokenChannel;
    		// jc.g:130:6: ( '+' )
    		DebugEnterAlt(1);
    		// jc.g:130:8: '+'
    		{
    		DebugLocation(130, 8);
    		Match('+'); if (state.failed) return;

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("PLUS", 32);
    		LeaveRule("PLUS", 32);
    		LeaveRule_PLUS();
        }
    }
    // $ANTLR end "PLUS"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_MINUS() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_MINUS() {}

    // $ANTLR start "MINUS"
    [GrammarRule("MINUS")]
    private void mMINUS()
    {
    	EnterRule_MINUS();
    	EnterRule("MINUS", 33);
    	TraceIn("MINUS", 33);
    		try
    		{
    		int _type = MINUS;
    		int _channel = DefaultTokenChannel;
    		// jc.g:131:7: ( '-' )
    		DebugEnterAlt(1);
    		// jc.g:131:9: '-'
    		{
    		DebugLocation(131, 9);
    		Match('-'); if (state.failed) return;

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("MINUS", 33);
    		LeaveRule("MINUS", 33);
    		LeaveRule_MINUS();
        }
    }
    // $ANTLR end "MINUS"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_MUL() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_MUL() {}

    // $ANTLR start "MUL"
    [GrammarRule("MUL")]
    private void mMUL()
    {
    	EnterRule_MUL();
    	EnterRule("MUL", 34);
    	TraceIn("MUL", 34);
    		try
    		{
    		int _type = MUL;
    		int _channel = DefaultTokenChannel;
    		// jc.g:132:5: ( '*' )
    		DebugEnterAlt(1);
    		// jc.g:132:7: '*'
    		{
    		DebugLocation(132, 7);
    		Match('*'); if (state.failed) return;

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("MUL", 34);
    		LeaveRule("MUL", 34);
    		LeaveRule_MUL();
        }
    }
    // $ANTLR end "MUL"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_DIV() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_DIV() {}

    // $ANTLR start "DIV"
    [GrammarRule("DIV")]
    private void mDIV()
    {
    	EnterRule_DIV();
    	EnterRule("DIV", 35);
    	TraceIn("DIV", 35);
    		try
    		{
    		int _type = DIV;
    		int _channel = DefaultTokenChannel;
    		// jc.g:133:5: ( '/' )
    		DebugEnterAlt(1);
    		// jc.g:133:7: '/'
    		{
    		DebugLocation(133, 7);
    		Match('/'); if (state.failed) return;

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("DIV", 35);
    		LeaveRule("DIV", 35);
    		LeaveRule_DIV();
        }
    }
    // $ANTLR end "DIV"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_MOD() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_MOD() {}

    // $ANTLR start "MOD"
    [GrammarRule("MOD")]
    private void mMOD()
    {
    	EnterRule_MOD();
    	EnterRule("MOD", 36);
    	TraceIn("MOD", 36);
    		try
    		{
    		int _type = MOD;
    		int _channel = DefaultTokenChannel;
    		// jc.g:134:5: ( '%' )
    		DebugEnterAlt(1);
    		// jc.g:134:7: '%'
    		{
    		DebugLocation(134, 7);
    		Match('%'); if (state.failed) return;

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("MOD", 36);
    		LeaveRule("MOD", 36);
    		LeaveRule_MOD();
        }
    }
    // $ANTLR end "MOD"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_ASSIGN() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_ASSIGN() {}

    // $ANTLR start "ASSIGN"
    [GrammarRule("ASSIGN")]
    private void mASSIGN()
    {
    	EnterRule_ASSIGN();
    	EnterRule("ASSIGN", 37);
    	TraceIn("ASSIGN", 37);
    		try
    		{
    		int _type = ASSIGN;
    		int _channel = DefaultTokenChannel;
    		// jc.g:135:8: ( '=' )
    		DebugEnterAlt(1);
    		// jc.g:135:10: '='
    		{
    		DebugLocation(135, 10);
    		Match('='); if (state.failed) return;

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("ASSIGN", 37);
    		LeaveRule("ASSIGN", 37);
    		LeaveRule_ASSIGN();
        }
    }
    // $ANTLR end "ASSIGN"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_NUMBER() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_NUMBER() {}

    // $ANTLR start "NUMBER"
    [GrammarRule("NUMBER")]
    private void mNUMBER()
    {
    	EnterRule_NUMBER();
    	EnterRule("NUMBER", 38);
    	TraceIn("NUMBER", 38);
    		try
    		{
    		int _type = NUMBER;
    		int _channel = DefaultTokenChannel;
    		// jc.g:137:8: ( ( '-' )? ( DIGIT )+ ( '.' ( DIGIT )+ )? )
    		DebugEnterAlt(1);
    		// jc.g:137:10: ( '-' )? ( DIGIT )+ ( '.' ( DIGIT )+ )?
    		{
    		DebugLocation(137, 10);
    		// jc.g:137:10: ( '-' )?
    		int alt6=2;
    		try { DebugEnterSubRule(6);
    		try { DebugEnterDecision(6, decisionCanBacktrack[6]);
    		int LA6_0 = input.LA(1);

    		if ((LA6_0=='-'))
    		{
    			alt6 = 1;
    		}
    		} finally { DebugExitDecision(6); }
    		switch (alt6)
    		{
    		case 1:
    			DebugEnterAlt(1);
    			// jc.g:137:10: '-'
    			{
    			DebugLocation(137, 10);
    			Match('-'); if (state.failed) return;

    			}
    			break;

    		}
    		} finally { DebugExitSubRule(6); }

    		DebugLocation(137, 15);
    		// jc.g:137:15: ( DIGIT )+
    		int cnt7=0;
    		try { DebugEnterSubRule(7);
    		while (true)
    		{
    			int alt7=2;
    			try { DebugEnterDecision(7, decisionCanBacktrack[7]);
    			int LA7_0 = input.LA(1);

    			if (((LA7_0>='0' && LA7_0<='9')))
    			{
    				alt7 = 1;
    			}


    			} finally { DebugExitDecision(7); }
    			switch (alt7)
    			{
    			case 1:
    				DebugEnterAlt(1);
    				// jc.g:
    				{
    				DebugLocation(137, 15);
    				input.Consume();
    				state.failed=false;

    				}
    				break;

    			default:
    				if (cnt7 >= 1)
    					goto loop7;

    				if (state.backtracking>0) {state.failed=true; return;}
    				EarlyExitException eee7 = new EarlyExitException( 7, input );
    				DebugRecognitionException(eee7);
    				throw eee7;
    			}
    			cnt7++;
    		}
    		loop7:
    			;

    		} finally { DebugExitSubRule(7); }

    		DebugLocation(137, 22);
    		// jc.g:137:22: ( '.' ( DIGIT )+ )?
    		int alt9=2;
    		try { DebugEnterSubRule(9);
    		try { DebugEnterDecision(9, decisionCanBacktrack[9]);
    		int LA9_0 = input.LA(1);

    		if ((LA9_0=='.'))
    		{
    			alt9 = 1;
    		}
    		} finally { DebugExitDecision(9); }
    		switch (alt9)
    		{
    		case 1:
    			DebugEnterAlt(1);
    			// jc.g:137:23: '.' ( DIGIT )+
    			{
    			DebugLocation(137, 23);
    			Match('.'); if (state.failed) return;
    			DebugLocation(137, 27);
    			// jc.g:137:27: ( DIGIT )+
    			int cnt8=0;
    			try { DebugEnterSubRule(8);
    			while (true)
    			{
    				int alt8=2;
    				try { DebugEnterDecision(8, decisionCanBacktrack[8]);
    				int LA8_0 = input.LA(1);

    				if (((LA8_0>='0' && LA8_0<='9')))
    				{
    					alt8 = 1;
    				}


    				} finally { DebugExitDecision(8); }
    				switch (alt8)
    				{
    				case 1:
    					DebugEnterAlt(1);
    					// jc.g:
    					{
    					DebugLocation(137, 27);
    					input.Consume();
    					state.failed=false;

    					}
    					break;

    				default:
    					if (cnt8 >= 1)
    						goto loop8;

    					if (state.backtracking>0) {state.failed=true; return;}
    					EarlyExitException eee8 = new EarlyExitException( 8, input );
    					DebugRecognitionException(eee8);
    					throw eee8;
    				}
    				cnt8++;
    			}
    			loop8:
    				;

    			} finally { DebugExitSubRule(8); }


    			}
    			break;

    		}
    		} finally { DebugExitSubRule(9); }


    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("NUMBER", 38);
    		LeaveRule("NUMBER", 38);
    		LeaveRule_NUMBER();
        }
    }
    // $ANTLR end "NUMBER"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_STRING() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_STRING() {}

    // $ANTLR start "STRING"
    [GrammarRule("STRING")]
    private void mSTRING()
    {
    	EnterRule_STRING();
    	EnterRule("STRING", 39);
    	TraceIn("STRING", 39);
    		try
    		{
    		int _type = STRING;
    		int _channel = DefaultTokenChannel;
    		int c = 0;

    		 System.Text.StringBuilder b = new System.Text.StringBuilder(); 
    		// jc.g:143:2: ( '\"' ( '\\\\' '\"' |c=~ ( '\"' ) )* '\"' )
    		DebugEnterAlt(1);
    		// jc.g:143:4: '\"' ( '\\\\' '\"' |c=~ ( '\"' ) )* '\"'
    		{
    		DebugLocation(143, 4);
    		Match('\"'); if (state.failed) return;
    		DebugLocation(144, 3);
    		// jc.g:144:3: ( '\\\\' '\"' |c=~ ( '\"' ) )*
    		try { DebugEnterSubRule(10);
    		while (true)
    		{
    			int alt10=3;
    			try { DebugEnterDecision(10, decisionCanBacktrack[10]);
    			int LA10_0 = input.LA(1);

    			if ((LA10_0=='\\'))
    			{
    				int LA10_2 = input.LA(2);

    				if ((LA10_2=='\"'))
    				{
    					int LA10_4 = input.LA(3);

    					if (((LA10_4>='\u0000' && LA10_4<='\uFFFF')))
    					{
    						alt10 = 1;
    					}

    					else
    					{
    						alt10 = 2;
    					}


    				}
    				else if (((LA10_2>='\u0000' && LA10_2<='!')||(LA10_2>='#' && LA10_2<='\uFFFF')))
    				{
    					alt10 = 2;
    				}


    			}
    			else if (((LA10_0>='\u0000' && LA10_0<='!')||(LA10_0>='#' && LA10_0<='[')||(LA10_0>=']' && LA10_0<='\uFFFF')))
    			{
    				alt10 = 2;
    			}


    			} finally { DebugExitDecision(10); }
    			switch ( alt10 )
    			{
    			case 1:
    				DebugEnterAlt(1);
    				// jc.g:144:5: '\\\\' '\"'
    				{
    				DebugLocation(144, 5);
    				Match('\\'); if (state.failed) return;
    				DebugLocation(144, 10);
    				Match('\"'); if (state.failed) return;
    				DebugLocation(144, 16);
    				if (state.backtracking == 0)
    				{
    					 b.Append('"');
    				}

    				}
    				break;
    			case 2:
    				DebugEnterAlt(2);
    				// jc.g:145:5: c=~ ( '\"' )
    				{
    				DebugLocation(145, 6);
    				c= input.LA(1);
    				input.Consume();
    				state.failed=false;
    				DebugLocation(145, 16);
    				if (state.backtracking == 0)
    				{
    					 b.Append((char)c);
    				}

    				}
    				break;

    			default:
    				goto loop10;
    			}
    		}

    		loop10:
    			;

    		} finally { DebugExitSubRule(10); }

    		DebugLocation(147, 3);
    		Match('\"'); if (state.failed) return;
    		DebugLocation(148, 3);
    		if (state.backtracking == 0)
    		{
    			 Text = b.ToString(); 
    		}

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("STRING", 39);
    		LeaveRule("STRING", 39);
    		LeaveRule_STRING();
        }
    }
    // $ANTLR end "STRING"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_DATE() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_DATE() {}

    // $ANTLR start "DATE"
    [GrammarRule("DATE")]
    private void mDATE()
    {
    	EnterRule_DATE();
    	EnterRule("DATE", 40);
    	TraceIn("DATE", 40);
    		try
    		{
    		int _type = DATE;
    		int _channel = DefaultTokenChannel;
    		// jc.g:151:6: ( DATE_FRAG ( ( ' ' TIME_FRAG )=> ' ' TIME_FRAG )? )
    		DebugEnterAlt(1);
    		// jc.g:151:8: DATE_FRAG ( ( ' ' TIME_FRAG )=> ' ' TIME_FRAG )?
    		{
    		DebugLocation(151, 8);
    		mDATE_FRAG(); if (state.failed) return;
    		DebugLocation(151, 18);
    		// jc.g:151:18: ( ( ' ' TIME_FRAG )=> ' ' TIME_FRAG )?
    		int alt11=2;
    		try { DebugEnterSubRule(11);
    		try { DebugEnterDecision(11, decisionCanBacktrack[11]);
    		int LA11_0 = input.LA(1);

    		if ((LA11_0==' ') && (EvaluatePredicate(synpred2_jc_fragment)))
    		{
    			alt11 = 1;
    		}
    		} finally { DebugExitDecision(11); }
    		switch (alt11)
    		{
    		case 1:
    			DebugEnterAlt(1);
    			// jc.g:151:19: ( ' ' TIME_FRAG )=> ' ' TIME_FRAG
    			{
    			DebugLocation(151, 38);
    			Match(' '); if (state.failed) return;
    			DebugLocation(151, 42);
    			mTIME_FRAG(); if (state.failed) return;
    			DebugLocation(151, 52);
    			if (state.backtracking == 0)
    			{
    				_type=DATETIME;
    			}

    			}
    			break;

    		}
    		} finally { DebugExitSubRule(11); }


    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("DATE", 40);
    		LeaveRule("DATE", 40);
    		LeaveRule_DATE();
        }
    }
    // $ANTLR end "DATE"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_TIME() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_TIME() {}

    // $ANTLR start "TIME"
    [GrammarRule("TIME")]
    private void mTIME()
    {
    	EnterRule_TIME();
    	EnterRule("TIME", 41);
    	TraceIn("TIME", 41);
    		try
    		{
    		int _type = TIME;
    		int _channel = DefaultTokenChannel;
    		// jc.g:152:6: ( TIME_FRAG )
    		DebugEnterAlt(1);
    		// jc.g:152:8: TIME_FRAG
    		{
    		DebugLocation(152, 8);
    		mTIME_FRAG(); if (state.failed) return;

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("TIME", 41);
    		LeaveRule("TIME", 41);
    		LeaveRule_TIME();
        }
    }
    // $ANTLR end "TIME"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_WS() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_WS() {}

    // $ANTLR start "WS"
    [GrammarRule("WS")]
    private void mWS()
    {
    	EnterRule_WS();
    	EnterRule("WS", 42);
    	TraceIn("WS", 42);
    		try
    		{
    		int _type = WS;
    		int _channel = DefaultTokenChannel;
    		// jc.g:154:4: ( ( ' ' | '\\t' | '\\n' | '\\r' | '\\f' )+ )
    		DebugEnterAlt(1);
    		// jc.g:154:6: ( ' ' | '\\t' | '\\n' | '\\r' | '\\f' )+
    		{
    		DebugLocation(154, 6);
    		// jc.g:154:6: ( ' ' | '\\t' | '\\n' | '\\r' | '\\f' )+
    		int cnt12=0;
    		try { DebugEnterSubRule(12);
    		while (true)
    		{
    			int alt12=2;
    			try { DebugEnterDecision(12, decisionCanBacktrack[12]);
    			int LA12_0 = input.LA(1);

    			if (((LA12_0>='\t' && LA12_0<='\n')||(LA12_0>='\f' && LA12_0<='\r')||LA12_0==' '))
    			{
    				alt12 = 1;
    			}


    			} finally { DebugExitDecision(12); }
    			switch (alt12)
    			{
    			case 1:
    				DebugEnterAlt(1);
    				// jc.g:
    				{
    				DebugLocation(154, 6);
    				input.Consume();
    				state.failed=false;

    				}
    				break;

    			default:
    				if (cnt12 >= 1)
    					goto loop12;

    				if (state.backtracking>0) {state.failed=true; return;}
    				EarlyExitException eee12 = new EarlyExitException( 12, input );
    				DebugRecognitionException(eee12);
    				throw eee12;
    			}
    			cnt12++;
    		}
    		loop12:
    			;

    		} finally { DebugExitSubRule(12); }

    		DebugLocation(154, 41);
    		if (state.backtracking == 0)
    		{
    			_channel = Hidden;
    		}

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("WS", 42);
    		LeaveRule("WS", 42);
    		LeaveRule_WS();
        }
    }
    // $ANTLR end "WS"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_COMMENT() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_COMMENT() {}

    // $ANTLR start "COMMENT"
    [GrammarRule("COMMENT")]
    private void mCOMMENT()
    {
    	EnterRule_COMMENT();
    	EnterRule("COMMENT", 43);
    	TraceIn("COMMENT", 43);
    		try
    		{
    		int _type = COMMENT;
    		int _channel = DefaultTokenChannel;
    		// jc.g:156:9: ( '//' ( . )* ( '\\n' | '\\r' ) )
    		DebugEnterAlt(1);
    		// jc.g:156:11: '//' ( . )* ( '\\n' | '\\r' )
    		{
    		DebugLocation(156, 11);
    		Match("//"); if (state.failed) return;

    		DebugLocation(156, 16);
    		// jc.g:156:16: ( . )*
    		try { DebugEnterSubRule(13);
    		while (true)
    		{
    			int alt13=2;
    			try { DebugEnterDecision(13, decisionCanBacktrack[13]);
    			int LA13_0 = input.LA(1);

    			if ((LA13_0=='\n'||LA13_0=='\r'))
    			{
    				alt13 = 2;
    			}
    			else if (((LA13_0>='\u0000' && LA13_0<='\t')||(LA13_0>='\u000B' && LA13_0<='\f')||(LA13_0>='\u000E' && LA13_0<='\uFFFF')))
    			{
    				alt13 = 1;
    			}


    			} finally { DebugExitDecision(13); }
    			switch ( alt13 )
    			{
    			case 1:
    				DebugEnterAlt(1);
    				// jc.g:156:16: .
    				{
    				DebugLocation(156, 16);
    				MatchAny(); if (state.failed) return;

    				}
    				break;

    			default:
    				goto loop13;
    			}
    		}

    		loop13:
    			;

    		} finally { DebugExitSubRule(13); }

    		DebugLocation(156, 19);
    		if (input.LA(1)=='\n'||input.LA(1)=='\r')
    		{
    			input.Consume();
    		state.failed=false;
    		}
    		else
    		{
    			if (state.backtracking>0) {state.failed=true; return;}
    			MismatchedSetException mse = new MismatchedSetException(null,input);
    			DebugRecognitionException(mse);
    			Recover(mse);
    			throw mse;
    		}

    		DebugLocation(156, 31);
    		if (state.backtracking == 0)
    		{
    			_channel = Hidden;
    		}

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("COMMENT", 43);
    		LeaveRule("COMMENT", 43);
    		LeaveRule_COMMENT();
        }
    }
    // $ANTLR end "COMMENT"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_MULTILINE_COMMENT() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_MULTILINE_COMMENT() {}

    // $ANTLR start "MULTILINE_COMMENT"
    [GrammarRule("MULTILINE_COMMENT")]
    private void mMULTILINE_COMMENT()
    {
    	EnterRule_MULTILINE_COMMENT();
    	EnterRule("MULTILINE_COMMENT", 44);
    	TraceIn("MULTILINE_COMMENT", 44);
    		try
    		{
    		int _type = MULTILINE_COMMENT;
    		int _channel = DefaultTokenChannel;
    		// jc.g:157:19: ( '/*' ( . )* '*/' )
    		DebugEnterAlt(1);
    		// jc.g:157:21: '/*' ( . )* '*/'
    		{
    		DebugLocation(157, 21);
    		Match("/*"); if (state.failed) return;

    		DebugLocation(157, 26);
    		// jc.g:157:26: ( . )*
    		try { DebugEnterSubRule(14);
    		while (true)
    		{
    			int alt14=2;
    			try { DebugEnterDecision(14, decisionCanBacktrack[14]);
    			int LA14_0 = input.LA(1);

    			if ((LA14_0=='*'))
    			{
    				int LA14_1 = input.LA(2);

    				if ((LA14_1=='/'))
    				{
    					alt14 = 2;
    				}
    				else if (((LA14_1>='\u0000' && LA14_1<='.')||(LA14_1>='0' && LA14_1<='\uFFFF')))
    				{
    					alt14 = 1;
    				}


    			}
    			else if (((LA14_0>='\u0000' && LA14_0<=')')||(LA14_0>='+' && LA14_0<='\uFFFF')))
    			{
    				alt14 = 1;
    			}


    			} finally { DebugExitDecision(14); }
    			switch ( alt14 )
    			{
    			case 1:
    				DebugEnterAlt(1);
    				// jc.g:157:26: .
    				{
    				DebugLocation(157, 26);
    				MatchAny(); if (state.failed) return;

    				}
    				break;

    			default:
    				goto loop14;
    			}
    		}

    		loop14:
    			;

    		} finally { DebugExitSubRule(14); }

    		DebugLocation(157, 29);
    		Match("*/"); if (state.failed) return;

    		DebugLocation(157, 34);
    		if (state.backtracking == 0)
    		{
    			_channel = Hidden;
    		}

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("MULTILINE_COMMENT", 44);
    		LeaveRule("MULTILINE_COMMENT", 44);
    		LeaveRule_MULTILINE_COMMENT();
        }
    }
    // $ANTLR end "MULTILINE_COMMENT"

    public override void mTokens()
    {
    	// jc.g:1:8: ( T__41 | T__42 | T__43 | T__44 | T__45 | T__46 | T__47 | TYPE | BOOL | NAME | DOT | COMMA | SEMICOL | OPEN_PAR | CLOSE_PAR | OPEN_BRACE | CLOSE_BRACE | PLUS | MINUS | MUL | DIV | MOD | ASSIGN | NUMBER | STRING | DATE | TIME | WS | COMMENT | MULTILINE_COMMENT )
    	int alt15=30;
    	try { DebugEnterDecision(15, decisionCanBacktrack[15]);
    	try
    	{
    		alt15 = dfa15.Predict(input);
    	}
    	catch (NoViableAltException nvae)
    	{
    		DebugRecognitionException(nvae);
    		throw;
    	}
    	} finally { DebugExitDecision(15); }
    	switch (alt15)
    	{
    	case 1:
    		DebugEnterAlt(1);
    		// jc.g:1:10: T__41
    		{
    		DebugLocation(1, 10);
    		mT__41(); if (state.failed) return;

    		}
    		break;
    	case 2:
    		DebugEnterAlt(2);
    		// jc.g:1:16: T__42
    		{
    		DebugLocation(1, 16);
    		mT__42(); if (state.failed) return;

    		}
    		break;
    	case 3:
    		DebugEnterAlt(3);
    		// jc.g:1:22: T__43
    		{
    		DebugLocation(1, 22);
    		mT__43(); if (state.failed) return;

    		}
    		break;
    	case 4:
    		DebugEnterAlt(4);
    		// jc.g:1:28: T__44
    		{
    		DebugLocation(1, 28);
    		mT__44(); if (state.failed) return;

    		}
    		break;
    	case 5:
    		DebugEnterAlt(5);
    		// jc.g:1:34: T__45
    		{
    		DebugLocation(1, 34);
    		mT__45(); if (state.failed) return;

    		}
    		break;
    	case 6:
    		DebugEnterAlt(6);
    		// jc.g:1:40: T__46
    		{
    		DebugLocation(1, 40);
    		mT__46(); if (state.failed) return;

    		}
    		break;
    	case 7:
    		DebugEnterAlt(7);
    		// jc.g:1:46: T__47
    		{
    		DebugLocation(1, 46);
    		mT__47(); if (state.failed) return;

    		}
    		break;
    	case 8:
    		DebugEnterAlt(8);
    		// jc.g:1:52: TYPE
    		{
    		DebugLocation(1, 52);
    		mTYPE(); if (state.failed) return;

    		}
    		break;
    	case 9:
    		DebugEnterAlt(9);
    		// jc.g:1:57: BOOL
    		{
    		DebugLocation(1, 57);
    		mBOOL(); if (state.failed) return;

    		}
    		break;
    	case 10:
    		DebugEnterAlt(10);
    		// jc.g:1:62: NAME
    		{
    		DebugLocation(1, 62);
    		mNAME(); if (state.failed) return;

    		}
    		break;
    	case 11:
    		DebugEnterAlt(11);
    		// jc.g:1:67: DOT
    		{
    		DebugLocation(1, 67);
    		mDOT(); if (state.failed) return;

    		}
    		break;
    	case 12:
    		DebugEnterAlt(12);
    		// jc.g:1:71: COMMA
    		{
    		DebugLocation(1, 71);
    		mCOMMA(); if (state.failed) return;

    		}
    		break;
    	case 13:
    		DebugEnterAlt(13);
    		// jc.g:1:77: SEMICOL
    		{
    		DebugLocation(1, 77);
    		mSEMICOL(); if (state.failed) return;

    		}
    		break;
    	case 14:
    		DebugEnterAlt(14);
    		// jc.g:1:85: OPEN_PAR
    		{
    		DebugLocation(1, 85);
    		mOPEN_PAR(); if (state.failed) return;

    		}
    		break;
    	case 15:
    		DebugEnterAlt(15);
    		// jc.g:1:94: CLOSE_PAR
    		{
    		DebugLocation(1, 94);
    		mCLOSE_PAR(); if (state.failed) return;

    		}
    		break;
    	case 16:
    		DebugEnterAlt(16);
    		// jc.g:1:104: OPEN_BRACE
    		{
    		DebugLocation(1, 104);
    		mOPEN_BRACE(); if (state.failed) return;

    		}
    		break;
    	case 17:
    		DebugEnterAlt(17);
    		// jc.g:1:115: CLOSE_BRACE
    		{
    		DebugLocation(1, 115);
    		mCLOSE_BRACE(); if (state.failed) return;

    		}
    		break;
    	case 18:
    		DebugEnterAlt(18);
    		// jc.g:1:127: PLUS
    		{
    		DebugLocation(1, 127);
    		mPLUS(); if (state.failed) return;

    		}
    		break;
    	case 19:
    		DebugEnterAlt(19);
    		// jc.g:1:132: MINUS
    		{
    		DebugLocation(1, 132);
    		mMINUS(); if (state.failed) return;

    		}
    		break;
    	case 20:
    		DebugEnterAlt(20);
    		// jc.g:1:138: MUL
    		{
    		DebugLocation(1, 138);
    		mMUL(); if (state.failed) return;

    		}
    		break;
    	case 21:
    		DebugEnterAlt(21);
    		// jc.g:1:142: DIV
    		{
    		DebugLocation(1, 142);
    		mDIV(); if (state.failed) return;

    		}
    		break;
    	case 22:
    		DebugEnterAlt(22);
    		// jc.g:1:146: MOD
    		{
    		DebugLocation(1, 146);
    		mMOD(); if (state.failed) return;

    		}
    		break;
    	case 23:
    		DebugEnterAlt(23);
    		// jc.g:1:150: ASSIGN
    		{
    		DebugLocation(1, 150);
    		mASSIGN(); if (state.failed) return;

    		}
    		break;
    	case 24:
    		DebugEnterAlt(24);
    		// jc.g:1:157: NUMBER
    		{
    		DebugLocation(1, 157);
    		mNUMBER(); if (state.failed) return;

    		}
    		break;
    	case 25:
    		DebugEnterAlt(25);
    		// jc.g:1:164: STRING
    		{
    		DebugLocation(1, 164);
    		mSTRING(); if (state.failed) return;

    		}
    		break;
    	case 26:
    		DebugEnterAlt(26);
    		// jc.g:1:171: DATE
    		{
    		DebugLocation(1, 171);
    		mDATE(); if (state.failed) return;

    		}
    		break;
    	case 27:
    		DebugEnterAlt(27);
    		// jc.g:1:176: TIME
    		{
    		DebugLocation(1, 176);
    		mTIME(); if (state.failed) return;

    		}
    		break;
    	case 28:
    		DebugEnterAlt(28);
    		// jc.g:1:181: WS
    		{
    		DebugLocation(1, 181);
    		mWS(); if (state.failed) return;

    		}
    		break;
    	case 29:
    		DebugEnterAlt(29);
    		// jc.g:1:184: COMMENT
    		{
    		DebugLocation(1, 184);
    		mCOMMENT(); if (state.failed) return;

    		}
    		break;
    	case 30:
    		DebugEnterAlt(30);
    		// jc.g:1:192: MULTILINE_COMMENT
    		{
    		DebugLocation(1, 192);
    		mMULTILINE_COMMENT(); if (state.failed) return;

    		}
    		break;

    	}

    }
    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_synpred1_jc_fragment() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_synpred1_jc_fragment() {}

    // $ANTLR start synpred1_jc
    public void synpred1_jc_fragment()
    {
    	EnterRule_synpred1_jc_fragment();
    	EnterRule("synpred1_jc_fragment", 46);
    	TraceIn("synpred1_jc_fragment", 46);
    	try
    	{
    		// jc.g:121:15: ( '.' IDENT )
    		DebugEnterAlt(1);
    		// jc.g:121:16: '.' IDENT
    		{
    		DebugLocation(121, 16);
    		Match('.'); if (state.failed) return;
    		DebugLocation(121, 20);
    		mIDENT(); if (state.failed) return;

    		}

    	}
    	finally
    	{
    		TraceOut("synpred1_jc_fragment", 46);
    		LeaveRule("synpred1_jc_fragment", 46);
    		LeaveRule_synpred1_jc_fragment();
    	}
    }
    // $ANTLR end synpred1_jc
    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_synpred2_jc_fragment() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_synpred2_jc_fragment() {}

    // $ANTLR start synpred2_jc
    public void synpred2_jc_fragment()
    {
    	EnterRule_synpred2_jc_fragment();
    	EnterRule("synpred2_jc_fragment", 47);
    	TraceIn("synpred2_jc_fragment", 47);
    	try
    	{
    		// jc.g:151:19: ( ' ' TIME_FRAG )
    		DebugEnterAlt(1);
    		// jc.g:151:20: ' ' TIME_FRAG
    		{
    		DebugLocation(151, 20);
    		Match(' '); if (state.failed) return;
    		DebugLocation(151, 24);
    		mTIME_FRAG(); if (state.failed) return;

    		}

    	}
    	finally
    	{
    		TraceOut("synpred2_jc_fragment", 47);
    		LeaveRule("synpred2_jc_fragment", 47);
    		LeaveRule_synpred2_jc_fragment();
    	}
    }
    // $ANTLR end synpred2_jc

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA
	DFA15 dfa15;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa15 = new DFA15(this);
	}

	private class DFA15 : DFA
	{
		private const string DFA15_eotS =
			"\x2\xFFFF\xA\xC\x9\xFFFF\x1\x2A\x1\xFFFF\x1\x2E\x2\xFFFF\x1\x2B\x2\xFFFF"+
			"\x3\xC\x1\x33\x9\xC\x5\xFFFF\x1\x2B\x2\xC\x1\x41\x1\xFFFF\x1\xC\x1\x43"+
			"\x1\xC\x1\x45\x5\xC\x1\x2B\x1\xFFFF\x2\xC\x1\xFFFF\x1\xC\x1\xFFFF\x1"+
			"\xC\x1\xFFFF\x1\xC\x3\x51\x1\x53\x1\x2B\x1\xC\x1\x53\x3\xC\x1\xFFFF\x1"+
			"\xC\x2\xFFFF\x1\xC\x1\x5B\x2\x51\x2\xC\x1\xFFFF\x1\xC\x1\x5F\x1\x51\x1"+
			"\xFFFF";
		private const string DFA15_eofS =
			"\x60\xFFFF";
		private const string DFA15_minS =
			"\x1\x9\x1\xFFFF\x1\x61\x1\x65\x1\x66\x2\x65\x1\x61\x1\x75\x1\x6F\x1\x61"+
			"\x1\x69\x9\xFFFF\x1\x30\x1\xFFFF\x1\x2A\x2\xFFFF\x1\x30\x2\xFFFF\x1\x6E"+
			"\x1\x6C\x1\x74\x1\x2E\x2\x74\x2\x72\x1\x6D\x1\x6F\x1\x74\x1\x6D\x1\x75"+
			"\x5\xFFFF\x1\x30\x1\x63\x1\x73\x1\x2E\x1\xFFFF\x1\x75\x1\x2E\x1\x69\x1"+
			"\x2E\x1\x62\x1\x6C\x3\x65\x1\x30\x1\xFFFF\x1\x74\x1\x65\x1\xFFFF\x1\x72"+
			"\x1\xFFFF\x1\x6E\x1\xFFFF\x1\x65\x4\x2E\x1\x2D\x1\x69\x1\x2E\x1\x6E\x1"+
			"\x67\x1\x72\x1\xFFFF\x1\x69\x2\xFFFF\x1\x6F\x3\x2E\x1\x6D\x1\x6E\x1\xFFFF"+
			"\x1\x65\x2\x2E\x1\xFFFF";
		private const string DFA15_maxS =
			"\x1\x7D\x1\xFFFF\x1\x75\x1\x65\x1\x66\x1\x65\x1\x74\x1\x61\x1\x75\x1"+
			"\x6F\x1\x61\x1\x72\x9\xFFFF\x1\x39\x1\xFFFF\x1\x2F\x2\xFFFF\x1\x39\x2"+
			"\xFFFF\x1\x6E\x1\x6C\x1\x74\x1\x7A\x2\x74\x2\x72\x1\x6D\x1\x6F\x1\x74"+
			"\x1\x6D\x1\x75\x5\xFFFF\x1\x3A\x1\x63\x1\x73\x1\x7A\x1\xFFFF\x1\x75\x1"+
			"\x7A\x1\x69\x1\x7A\x1\x62\x1\x6C\x3\x65\x1\x39\x1\xFFFF\x1\x74\x1\x65"+
			"\x1\xFFFF\x1\x72\x1\xFFFF\x1\x6E\x1\xFFFF\x1\x65\x4\x7A\x1\x2D\x1\x69"+
			"\x1\x7A\x1\x6E\x1\x67\x1\x72\x1\xFFFF\x1\x69\x2\xFFFF\x1\x6F\x3\x7A\x1"+
			"\x6D\x1\x6E\x1\xFFFF\x1\x65\x2\x7A\x1\xFFFF";
		private const string DFA15_acceptS =
			"\x1\xFFFF\x1\x1\xA\xFFFF\x1\xA\x1\xB\x1\xC\x1\xD\x1\xE\x1\xF\x1\x10\x1"+
			"\x11\x1\x12\x1\xFFFF\x1\x14\x1\xFFFF\x1\x16\x1\x17\x1\xFFFF\x1\x19\x1"+
			"\x1C\xD\xFFFF\x1\x13\x1\x18\x1\x1D\x1\x1E\x1\x15\x4\xFFFF\x1\x4\xA\xFFFF"+
			"\x1\x1B\x2\xFFFF\x1\x3\x1\xFFFF\x1\x6\x1\xFFFF\x1\x7\xB\xFFFF\x1\x8\x1"+
			"\xFFFF\x1\x9\x1\x1A\x6\xFFFF\x1\x5\x3\xFFFF\x1\x2";
		private const string DFA15_specialS =
			"\x60\xFFFF}>";
		private static readonly string[] DFA15_transitionS =
			{
				"\x2\x1C\x1\xFFFF\x2\x1C\x12\xFFFF\x1\x1C\x1\xFFFF\x1\x1B\x2\xFFFF\x1"+
				"\x18\x2\xFFFF\x1\x10\x1\x11\x1\x16\x1\x14\x1\xE\x1\x15\x1\xD\x1\x17"+
				"\xA\x1A\x1\x1\x1\xF\x1\xFFFF\x1\x19\x3\xFFFF\x1A\xC\x6\xFFFF\x1\xC\x1"+
				"\x9\x1\xC\x1\xA\x1\xC\x1\x2\x1\x3\x1\xC\x1\x4\x4\xC\x1\x8\x3\xC\x1\x5"+
				"\x1\x6\x1\xB\x1\xC\x1\x7\x4\xC\x1\x12\x1\xFFFF\x1\x13",
				"",
				"\x1\x1E\x13\xFFFF\x1\x1D",
				"\x1\x1F",
				"\x1\x20",
				"\x1\x21",
				"\x1\x22\xE\xFFFF\x1\x23",
				"\x1\x24",
				"\x1\x25",
				"\x1\x26",
				"\x1\x27",
				"\x1\x28\x8\xFFFF\x1\x29",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\xA\x2B",
				"",
				"\x1\x2D\x4\xFFFF\x1\x2C",
				"",
				"",
				"\xA\x2F",
				"",
				"",
				"\x1\x30",
				"\x1\x31",
				"\x1\x32",
				"\x1\xC\x1\xFFFF\xA\xC\x7\xFFFF\x1A\xC\x6\xFFFF\x1A\xC",
				"\x1\x34",
				"\x1\x35",
				"\x1\x36",
				"\x1\x37",
				"\x1\x38",
				"\x1\x39",
				"\x1\x3A",
				"\x1\x3B",
				"\x1\x3C",
				"",
				"",
				"",
				"",
				"",
				"\xA\x3D\x1\x3E",
				"\x1\x3F",
				"\x1\x40",
				"\x1\xC\x1\xFFFF\xA\xC\x7\xFFFF\x1A\xC\x6\xFFFF\x1A\xC",
				"",
				"\x1\x42",
				"\x1\xC\x1\xFFFF\xA\xC\x7\xFFFF\x1A\xC\x6\xFFFF\x1A\xC",
				"\x1\x44",
				"\x1\xC\x1\xFFFF\xA\xC\x7\xFFFF\x1A\xC\x6\xFFFF\x1A\xC",
				"\x1\x46",
				"\x1\x47",
				"\x1\x48",
				"\x1\x49",
				"\x1\x4A",
				"\xA\x4B",
				"",
				"\x1\x4C",
				"\x1\x4D",
				"",
				"\x1\x4E",
				"",
				"\x1\x4F",
				"",
				"\x1\x50",
				"\x1\xC\x1\xFFFF\xA\xC\x7\xFFFF\x1A\xC\x6\xFFFF\x1A\xC",
				"\x1\xC\x1\xFFFF\xA\xC\x7\xFFFF\x1A\xC\x6\xFFFF\x13\xC\x1\x52\x6\xC",
				"\x1\xC\x1\xFFFF\xA\xC\x7\xFFFF\x1A\xC\x6\xFFFF\x1A\xC",
				"\x1\xC\x1\xFFFF\xA\xC\x7\xFFFF\x1A\xC\x6\xFFFF\x1A\xC",
				"\x1\x54",
				"\x1\x55",
				"\x1\xC\x1\xFFFF\xA\xC\x7\xFFFF\x1A\xC\x6\xFFFF\x1A\xC",
				"\x1\x56",
				"\x1\x57",
				"\x1\x58",
				"",
				"\x1\x59",
				"",
				"",
				"\x1\x5A",
				"\x1\xC\x1\xFFFF\xA\xC\x7\xFFFF\x1A\xC\x6\xFFFF\x1A\xC",
				"\x1\xC\x1\xFFFF\xA\xC\x7\xFFFF\x1A\xC\x6\xFFFF\x1A\xC",
				"\x1\xC\x1\xFFFF\xA\xC\x7\xFFFF\x1A\xC\x6\xFFFF\x1A\xC",
				"\x1\x5C",
				"\x1\x5D",
				"",
				"\x1\x5E",
				"\x1\xC\x1\xFFFF\xA\xC\x7\xFFFF\x1A\xC\x6\xFFFF\x1A\xC",
				"\x1\xC\x1\xFFFF\xA\xC\x7\xFFFF\x1A\xC\x6\xFFFF\x1A\xC",
				""
			};

		private static readonly short[] DFA15_eot = DFA.UnpackEncodedString(DFA15_eotS);
		private static readonly short[] DFA15_eof = DFA.UnpackEncodedString(DFA15_eofS);
		private static readonly char[] DFA15_min = DFA.UnpackEncodedStringToUnsignedChars(DFA15_minS);
		private static readonly char[] DFA15_max = DFA.UnpackEncodedStringToUnsignedChars(DFA15_maxS);
		private static readonly short[] DFA15_accept = DFA.UnpackEncodedString(DFA15_acceptS);
		private static readonly short[] DFA15_special = DFA.UnpackEncodedString(DFA15_specialS);
		private static readonly short[][] DFA15_transition;

		static DFA15()
		{
			int numStates = DFA15_transitionS.Length;
			DFA15_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA15_transition[i] = DFA.UnpackEncodedString(DFA15_transitionS[i]);
			}
		}

		public DFA15( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 15;
			this.eot = DFA15_eot;
			this.eof = DFA15_eof;
			this.min = DFA15_min;
			this.max = DFA15_max;
			this.accept = DFA15_accept;
			this.special = DFA15_special;
			this.transition = DFA15_transition;
		}

		public override string Description { get { return "1:1: Tokens : ( T__41 | T__42 | T__43 | T__44 | T__45 | T__46 | T__47 | TYPE | BOOL | NAME | DOT | COMMA | SEMICOL | OPEN_PAR | CLOSE_PAR | OPEN_BRACE | CLOSE_BRACE | PLUS | MINUS | MUL | DIV | MOD | ASSIGN | NUMBER | STRING | DATE | TIME | WS | COMMENT | MULTILINE_COMMENT );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

 
	#endregion

}
