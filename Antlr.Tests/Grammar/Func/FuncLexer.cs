//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 Func.g 2013-04-27 19:38:51

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 168, 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using ConditionalAttribute = System.Diagnostics.ConditionalAttribute;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class FuncLexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int BOOLEAN=4;
	public const int CLOSE_PAR=5;
	public const int COMMA=6;
	public const int COMMENT=7;
	public const int DATE=8;
	public const int DATETIME=9;
	public const int DATE_FRAG=10;
	public const int DAY=11;
	public const int DIGIT=12;
	public const int DOT=13;
	public const int FUNC=14;
	public const int HOUR=15;
	public const int IDENT=16;
	public const int LETTER=17;
	public const int METHOD=18;
	public const int MILLISECOND=19;
	public const int MINUTE=20;
	public const int MONTH=21;
	public const int MULTILINE_COMMENT=22;
	public const int NUMBER=23;
	public const int OPEN_PAR=24;
	public const int PATH=25;
	public const int SECOND=26;
	public const int SEMICOL=27;
	public const int STRING=28;
	public const int TIME=29;
	public const int TIME_FRAG=30;
	public const int VAR=31;
	public const int WS=32;
	public const int YEAR=33;

    // delegates
    // delegators

	public FuncLexer()
	{
		OnCreated();
	}

	public FuncLexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	public FuncLexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
	public override string GrammarFileName { get { return "Func.g"; } }

	private static readonly bool[] decisionCanBacktrack = new bool[0];

	[Conditional("ANTLR_TRACE")]
	protected virtual void OnCreated() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule(string ruleName, int ruleIndex) {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule(string ruleName, int ruleIndex) {}

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_LETTER() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_LETTER() {}

    // $ANTLR start "LETTER"
    [GrammarRule("LETTER")]
    private void mLETTER()
    {
    	EnterRule_LETTER();
    	EnterRule("LETTER", 1);
    	TraceIn("LETTER", 1);
    		try
    		{
    		// Func.g:33:17: ( ( 'a' .. 'z' | 'A' .. 'Z' ) )
    		DebugEnterAlt(1);
    		// Func.g:
    		{
    		DebugLocation(33, 17);
    		if ((input.LA(1)>='A' && input.LA(1)<='Z')||(input.LA(1)>='a' && input.LA(1)<='z'))
    		{
    			input.Consume();
    		state.failed=false;
    		}
    		else
    		{
    			if (state.backtracking>0) {state.failed=true; return;}
    			MismatchedSetException mse = new MismatchedSetException(null,input);
    			DebugRecognitionException(mse);
    			Recover(mse);
    			throw mse;
    		}


    		}

    	}
    	finally
    	{
    		TraceOut("LETTER", 1);
    		LeaveRule("LETTER", 1);
    		LeaveRule_LETTER();
        }
    }
    // $ANTLR end "LETTER"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_DIGIT() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_DIGIT() {}

    // $ANTLR start "DIGIT"
    [GrammarRule("DIGIT")]
    private void mDIGIT()
    {
    	EnterRule_DIGIT();
    	EnterRule("DIGIT", 2);
    	TraceIn("DIGIT", 2);
    		try
    		{
    		// Func.g:34:16: ( '0' .. '9' )
    		DebugEnterAlt(1);
    		// Func.g:
    		{
    		DebugLocation(34, 16);
    		if ((input.LA(1)>='0' && input.LA(1)<='9'))
    		{
    			input.Consume();
    		state.failed=false;
    		}
    		else
    		{
    			if (state.backtracking>0) {state.failed=true; return;}
    			MismatchedSetException mse = new MismatchedSetException(null,input);
    			DebugRecognitionException(mse);
    			Recover(mse);
    			throw mse;
    		}


    		}

    	}
    	finally
    	{
    		TraceOut("DIGIT", 2);
    		LeaveRule("DIGIT", 2);
    		LeaveRule_DIGIT();
        }
    }
    // $ANTLR end "DIGIT"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_IDENT() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_IDENT() {}

    // $ANTLR start "IDENT"
    [GrammarRule("IDENT")]
    private void mIDENT()
    {
    	EnterRule_IDENT();
    	EnterRule("IDENT", 3);
    	TraceIn("IDENT", 3);
    		try
    		{
    		// Func.g:35:16: ( LETTER ( LETTER | DIGIT )* )
    		DebugEnterAlt(1);
    		// Func.g:35:18: LETTER ( LETTER | DIGIT )*
    		{
    		DebugLocation(35, 18);
    		mLETTER(); if (state.failed) return;
    		DebugLocation(35, 25);
    		// Func.g:35:25: ( LETTER | DIGIT )*
    		try { DebugEnterSubRule(1);
    		while (true)
    		{
    			int alt1=2;
    			try { DebugEnterDecision(1, decisionCanBacktrack[1]);
    			int LA1_0 = input.LA(1);

    			if (((LA1_0>='0' && LA1_0<='9')||(LA1_0>='A' && LA1_0<='Z')||(LA1_0>='a' && LA1_0<='z')))
    			{
    				alt1 = 1;
    			}


    			} finally { DebugExitDecision(1); }
    			switch ( alt1 )
    			{
    			case 1:
    				DebugEnterAlt(1);
    				// Func.g:
    				{
    				DebugLocation(35, 25);
    				input.Consume();
    				state.failed=false;

    				}
    				break;

    			default:
    				goto loop1;
    			}
    		}

    		loop1:
    			;

    		} finally { DebugExitSubRule(1); }


    		}

    	}
    	finally
    	{
    		TraceOut("IDENT", 3);
    		LeaveRule("IDENT", 3);
    		LeaveRule_IDENT();
        }
    }
    // $ANTLR end "IDENT"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_YEAR() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_YEAR() {}

    // $ANTLR start "YEAR"
    [GrammarRule("YEAR")]
    private void mYEAR()
    {
    	EnterRule_YEAR();
    	EnterRule("YEAR", 4);
    	TraceIn("YEAR", 4);
    		try
    		{
    		// Func.g:37:15: ( DIGIT DIGIT DIGIT DIGIT )
    		DebugEnterAlt(1);
    		// Func.g:37:19: DIGIT DIGIT DIGIT DIGIT
    		{
    		DebugLocation(37, 19);
    		mDIGIT(); if (state.failed) return;
    		DebugLocation(37, 25);
    		mDIGIT(); if (state.failed) return;
    		DebugLocation(37, 31);
    		mDIGIT(); if (state.failed) return;
    		DebugLocation(37, 37);
    		mDIGIT(); if (state.failed) return;

    		}

    	}
    	finally
    	{
    		TraceOut("YEAR", 4);
    		LeaveRule("YEAR", 4);
    		LeaveRule_YEAR();
        }
    }
    // $ANTLR end "YEAR"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_MONTH() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_MONTH() {}

    // $ANTLR start "MONTH"
    [GrammarRule("MONTH")]
    private void mMONTH()
    {
    	EnterRule_MONTH();
    	EnterRule("MONTH", 5);
    	TraceIn("MONTH", 5);
    		try
    		{
    		// Func.g:38:16: ( DIGIT DIGIT )
    		DebugEnterAlt(1);
    		// Func.g:38:19: DIGIT DIGIT
    		{
    		DebugLocation(38, 19);
    		mDIGIT(); if (state.failed) return;
    		DebugLocation(38, 25);
    		mDIGIT(); if (state.failed) return;

    		}

    	}
    	finally
    	{
    		TraceOut("MONTH", 5);
    		LeaveRule("MONTH", 5);
    		LeaveRule_MONTH();
        }
    }
    // $ANTLR end "MONTH"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_DAY() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_DAY() {}

    // $ANTLR start "DAY"
    [GrammarRule("DAY")]
    private void mDAY()
    {
    	EnterRule_DAY();
    	EnterRule("DAY", 6);
    	TraceIn("DAY", 6);
    		try
    		{
    		// Func.g:39:14: ( DIGIT DIGIT )
    		DebugEnterAlt(1);
    		// Func.g:39:18: DIGIT DIGIT
    		{
    		DebugLocation(39, 18);
    		mDIGIT(); if (state.failed) return;
    		DebugLocation(39, 24);
    		mDIGIT(); if (state.failed) return;

    		}

    	}
    	finally
    	{
    		TraceOut("DAY", 6);
    		LeaveRule("DAY", 6);
    		LeaveRule_DAY();
        }
    }
    // $ANTLR end "DAY"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_HOUR() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_HOUR() {}

    // $ANTLR start "HOUR"
    [GrammarRule("HOUR")]
    private void mHOUR()
    {
    	EnterRule_HOUR();
    	EnterRule("HOUR", 7);
    	TraceIn("HOUR", 7);
    		try
    		{
    		// Func.g:40:15: ( DIGIT DIGIT )
    		DebugEnterAlt(1);
    		// Func.g:40:19: DIGIT DIGIT
    		{
    		DebugLocation(40, 19);
    		mDIGIT(); if (state.failed) return;
    		DebugLocation(40, 25);
    		mDIGIT(); if (state.failed) return;

    		}

    	}
    	finally
    	{
    		TraceOut("HOUR", 7);
    		LeaveRule("HOUR", 7);
    		LeaveRule_HOUR();
        }
    }
    // $ANTLR end "HOUR"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_MINUTE() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_MINUTE() {}

    // $ANTLR start "MINUTE"
    [GrammarRule("MINUTE")]
    private void mMINUTE()
    {
    	EnterRule_MINUTE();
    	EnterRule("MINUTE", 8);
    	TraceIn("MINUTE", 8);
    		try
    		{
    		// Func.g:41:17: ( DIGIT DIGIT )
    		DebugEnterAlt(1);
    		// Func.g:41:20: DIGIT DIGIT
    		{
    		DebugLocation(41, 20);
    		mDIGIT(); if (state.failed) return;
    		DebugLocation(41, 26);
    		mDIGIT(); if (state.failed) return;

    		}

    	}
    	finally
    	{
    		TraceOut("MINUTE", 8);
    		LeaveRule("MINUTE", 8);
    		LeaveRule_MINUTE();
        }
    }
    // $ANTLR end "MINUTE"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_SECOND() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_SECOND() {}

    // $ANTLR start "SECOND"
    [GrammarRule("SECOND")]
    private void mSECOND()
    {
    	EnterRule_SECOND();
    	EnterRule("SECOND", 9);
    	TraceIn("SECOND", 9);
    		try
    		{
    		// Func.g:42:17: ( DIGIT DIGIT )
    		DebugEnterAlt(1);
    		// Func.g:42:20: DIGIT DIGIT
    		{
    		DebugLocation(42, 20);
    		mDIGIT(); if (state.failed) return;
    		DebugLocation(42, 26);
    		mDIGIT(); if (state.failed) return;

    		}

    	}
    	finally
    	{
    		TraceOut("SECOND", 9);
    		LeaveRule("SECOND", 9);
    		LeaveRule_SECOND();
        }
    }
    // $ANTLR end "SECOND"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_MILLISECOND() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_MILLISECOND() {}

    // $ANTLR start "MILLISECOND"
    [GrammarRule("MILLISECOND")]
    private void mMILLISECOND()
    {
    	EnterRule_MILLISECOND();
    	EnterRule("MILLISECOND", 10);
    	TraceIn("MILLISECOND", 10);
    		try
    		{
    		// Func.g:43:22: ( DIGIT DIGIT DIGIT )
    		DebugEnterAlt(1);
    		// Func.g:43:24: DIGIT DIGIT DIGIT
    		{
    		DebugLocation(43, 24);
    		mDIGIT(); if (state.failed) return;
    		DebugLocation(43, 30);
    		mDIGIT(); if (state.failed) return;
    		DebugLocation(43, 36);
    		mDIGIT(); if (state.failed) return;

    		}

    	}
    	finally
    	{
    		TraceOut("MILLISECOND", 10);
    		LeaveRule("MILLISECOND", 10);
    		LeaveRule_MILLISECOND();
        }
    }
    // $ANTLR end "MILLISECOND"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_DATE_FRAG() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_DATE_FRAG() {}

    // $ANTLR start "DATE_FRAG"
    [GrammarRule("DATE_FRAG")]
    private void mDATE_FRAG()
    {
    	EnterRule_DATE_FRAG();
    	EnterRule("DATE_FRAG", 11);
    	TraceIn("DATE_FRAG", 11);
    		try
    		{
    		// Func.g:45:20: ( YEAR '-' MONTH '-' DAY )
    		DebugEnterAlt(1);
    		// Func.g:45:22: YEAR '-' MONTH '-' DAY
    		{
    		DebugLocation(45, 22);
    		mYEAR(); if (state.failed) return;
    		DebugLocation(45, 27);
    		Match('-'); if (state.failed) return;
    		DebugLocation(45, 31);
    		mMONTH(); if (state.failed) return;
    		DebugLocation(45, 37);
    		Match('-'); if (state.failed) return;
    		DebugLocation(45, 41);
    		mDAY(); if (state.failed) return;

    		}

    	}
    	finally
    	{
    		TraceOut("DATE_FRAG", 11);
    		LeaveRule("DATE_FRAG", 11);
    		LeaveRule_DATE_FRAG();
        }
    }
    // $ANTLR end "DATE_FRAG"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_TIME_FRAG() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_TIME_FRAG() {}

    // $ANTLR start "TIME_FRAG"
    [GrammarRule("TIME_FRAG")]
    private void mTIME_FRAG()
    {
    	EnterRule_TIME_FRAG();
    	EnterRule("TIME_FRAG", 12);
    	TraceIn("TIME_FRAG", 12);
    		try
    		{
    		// Func.g:46:20: ( HOUR ':' MINUTE ':' SECOND ( '.' MILLISECOND )? )
    		DebugEnterAlt(1);
    		// Func.g:46:22: HOUR ':' MINUTE ':' SECOND ( '.' MILLISECOND )?
    		{
    		DebugLocation(46, 22);
    		mHOUR(); if (state.failed) return;
    		DebugLocation(46, 27);
    		Match(':'); if (state.failed) return;
    		DebugLocation(46, 31);
    		mMINUTE(); if (state.failed) return;
    		DebugLocation(46, 38);
    		Match(':'); if (state.failed) return;
    		DebugLocation(46, 42);
    		mSECOND(); if (state.failed) return;
    		DebugLocation(46, 49);
    		// Func.g:46:49: ( '.' MILLISECOND )?
    		int alt2=2;
    		try { DebugEnterSubRule(2);
    		try { DebugEnterDecision(2, decisionCanBacktrack[2]);
    		int LA2_0 = input.LA(1);

    		if ((LA2_0=='.'))
    		{
    			alt2 = 1;
    		}
    		} finally { DebugExitDecision(2); }
    		switch (alt2)
    		{
    		case 1:
    			DebugEnterAlt(1);
    			// Func.g:46:50: '.' MILLISECOND
    			{
    			DebugLocation(46, 50);
    			Match('.'); if (state.failed) return;
    			DebugLocation(46, 54);
    			mMILLISECOND(); if (state.failed) return;

    			}
    			break;

    		}
    		} finally { DebugExitSubRule(2); }


    		}

    	}
    	finally
    	{
    		TraceOut("TIME_FRAG", 12);
    		LeaveRule("TIME_FRAG", 12);
    		LeaveRule_TIME_FRAG();
        }
    }
    // $ANTLR end "TIME_FRAG"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_DATETIME() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_DATETIME() {}

    // $ANTLR start "DATETIME"
    [GrammarRule("DATETIME")]
    private void mDATETIME()
    {
    	EnterRule_DATETIME();
    	EnterRule("DATETIME", 13);
    	TraceIn("DATETIME", 13);
    		try
    		{
    		// Func.g:48:19: ()
    		DebugEnterAlt(1);
    		// Func.g:48:21: 
    		{
    		}

    	}
    	finally
    	{
    		TraceOut("DATETIME", 13);
    		LeaveRule("DATETIME", 13);
    		LeaveRule_DATETIME();
        }
    }
    // $ANTLR end "DATETIME"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_PATH() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_PATH() {}

    // $ANTLR start "PATH"
    [GrammarRule("PATH")]
    private void mPATH()
    {
    	EnterRule_PATH();
    	EnterRule("PATH", 14);
    	TraceIn("PATH", 14);
    		try
    		{
    		// Func.g:49:15: ( IDENT ( '.' IDENT )* )
    		DebugEnterAlt(1);
    		// Func.g:49:17: IDENT ( '.' IDENT )*
    		{
    		DebugLocation(49, 17);
    		mIDENT(); if (state.failed) return;
    		DebugLocation(49, 23);
    		// Func.g:49:23: ( '.' IDENT )*
    		try { DebugEnterSubRule(3);
    		while (true)
    		{
    			int alt3=2;
    			try { DebugEnterDecision(3, decisionCanBacktrack[3]);
    			int LA3_0 = input.LA(1);

    			if ((LA3_0=='.'))
    			{
    				alt3 = 1;
    			}


    			} finally { DebugExitDecision(3); }
    			switch ( alt3 )
    			{
    			case 1:
    				DebugEnterAlt(1);
    				// Func.g:49:24: '.' IDENT
    				{
    				DebugLocation(49, 24);
    				Match('.'); if (state.failed) return;
    				DebugLocation(49, 28);
    				mIDENT(); if (state.failed) return;

    				}
    				break;

    			default:
    				goto loop3;
    			}
    		}

    		loop3:
    			;

    		} finally { DebugExitSubRule(3); }


    		}

    	}
    	finally
    	{
    		TraceOut("PATH", 14);
    		LeaveRule("PATH", 14);
    		LeaveRule_PATH();
        }
    }
    // $ANTLR end "PATH"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_METHOD() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_METHOD() {}

    // $ANTLR start "METHOD"
    [GrammarRule("METHOD")]
    private void mMETHOD()
    {
    	EnterRule_METHOD();
    	EnterRule("METHOD", 15);
    	TraceIn("METHOD", 15);
    		try
    		{
    		// Func.g:50:17: ()
    		DebugEnterAlt(1);
    		// Func.g:50:19: 
    		{
    		}

    	}
    	finally
    	{
    		TraceOut("METHOD", 15);
    		LeaveRule("METHOD", 15);
    		LeaveRule_METHOD();
        }
    }
    // $ANTLR end "METHOD"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_DOT() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_DOT() {}

    // $ANTLR start "DOT"
    [GrammarRule("DOT")]
    private void mDOT()
    {
    	EnterRule_DOT();
    	EnterRule("DOT", 16);
    	TraceIn("DOT", 16);
    		try
    		{
    		int _type = DOT;
    		int _channel = DefaultTokenChannel;
    		// Func.g:52:4: ( '.' )
    		DebugEnterAlt(1);
    		// Func.g:52:6: '.'
    		{
    		DebugLocation(52, 6);
    		Match('.'); if (state.failed) return;

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("DOT", 16);
    		LeaveRule("DOT", 16);
    		LeaveRule_DOT();
        }
    }
    // $ANTLR end "DOT"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_COMMA() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_COMMA() {}

    // $ANTLR start "COMMA"
    [GrammarRule("COMMA")]
    private void mCOMMA()
    {
    	EnterRule_COMMA();
    	EnterRule("COMMA", 17);
    	TraceIn("COMMA", 17);
    		try
    		{
    		int _type = COMMA;
    		int _channel = DefaultTokenChannel;
    		// Func.g:53:7: ( ',' )
    		DebugEnterAlt(1);
    		// Func.g:53:9: ','
    		{
    		DebugLocation(53, 9);
    		Match(','); if (state.failed) return;

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("COMMA", 17);
    		LeaveRule("COMMA", 17);
    		LeaveRule_COMMA();
        }
    }
    // $ANTLR end "COMMA"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_SEMICOL() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_SEMICOL() {}

    // $ANTLR start "SEMICOL"
    [GrammarRule("SEMICOL")]
    private void mSEMICOL()
    {
    	EnterRule_SEMICOL();
    	EnterRule("SEMICOL", 18);
    	TraceIn("SEMICOL", 18);
    		try
    		{
    		int _type = SEMICOL;
    		int _channel = DefaultTokenChannel;
    		// Func.g:54:9: ( ';' )
    		DebugEnterAlt(1);
    		// Func.g:54:11: ';'
    		{
    		DebugLocation(54, 11);
    		Match(';'); if (state.failed) return;

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("SEMICOL", 18);
    		LeaveRule("SEMICOL", 18);
    		LeaveRule_SEMICOL();
        }
    }
    // $ANTLR end "SEMICOL"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_OPEN_PAR() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_OPEN_PAR() {}

    // $ANTLR start "OPEN_PAR"
    [GrammarRule("OPEN_PAR")]
    private void mOPEN_PAR()
    {
    	EnterRule_OPEN_PAR();
    	EnterRule("OPEN_PAR", 19);
    	TraceIn("OPEN_PAR", 19);
    		try
    		{
    		int _type = OPEN_PAR;
    		int _channel = DefaultTokenChannel;
    		// Func.g:55:10: ( '(' )
    		DebugEnterAlt(1);
    		// Func.g:55:12: '('
    		{
    		DebugLocation(55, 12);
    		Match('('); if (state.failed) return;

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("OPEN_PAR", 19);
    		LeaveRule("OPEN_PAR", 19);
    		LeaveRule_OPEN_PAR();
        }
    }
    // $ANTLR end "OPEN_PAR"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_CLOSE_PAR() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_CLOSE_PAR() {}

    // $ANTLR start "CLOSE_PAR"
    [GrammarRule("CLOSE_PAR")]
    private void mCLOSE_PAR()
    {
    	EnterRule_CLOSE_PAR();
    	EnterRule("CLOSE_PAR", 20);
    	TraceIn("CLOSE_PAR", 20);
    		try
    		{
    		int _type = CLOSE_PAR;
    		int _channel = DefaultTokenChannel;
    		// Func.g:56:11: ( ')' )
    		DebugEnterAlt(1);
    		// Func.g:56:13: ')'
    		{
    		DebugLocation(56, 13);
    		Match(')'); if (state.failed) return;

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("CLOSE_PAR", 20);
    		LeaveRule("CLOSE_PAR", 20);
    		LeaveRule_CLOSE_PAR();
        }
    }
    // $ANTLR end "CLOSE_PAR"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_NUMBER() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_NUMBER() {}

    // $ANTLR start "NUMBER"
    [GrammarRule("NUMBER")]
    private void mNUMBER()
    {
    	EnterRule_NUMBER();
    	EnterRule("NUMBER", 21);
    	TraceIn("NUMBER", 21);
    		try
    		{
    		int _type = NUMBER;
    		int _channel = DefaultTokenChannel;
    		// Func.g:58:8: ( ( '-' )? ( DIGIT )+ ( '.' ( DIGIT )+ )? )
    		DebugEnterAlt(1);
    		// Func.g:58:10: ( '-' )? ( DIGIT )+ ( '.' ( DIGIT )+ )?
    		{
    		DebugLocation(58, 10);
    		// Func.g:58:10: ( '-' )?
    		int alt4=2;
    		try { DebugEnterSubRule(4);
    		try { DebugEnterDecision(4, decisionCanBacktrack[4]);
    		int LA4_0 = input.LA(1);

    		if ((LA4_0=='-'))
    		{
    			alt4 = 1;
    		}
    		} finally { DebugExitDecision(4); }
    		switch (alt4)
    		{
    		case 1:
    			DebugEnterAlt(1);
    			// Func.g:58:10: '-'
    			{
    			DebugLocation(58, 10);
    			Match('-'); if (state.failed) return;

    			}
    			break;

    		}
    		} finally { DebugExitSubRule(4); }

    		DebugLocation(58, 15);
    		// Func.g:58:15: ( DIGIT )+
    		int cnt5=0;
    		try { DebugEnterSubRule(5);
    		while (true)
    		{
    			int alt5=2;
    			try { DebugEnterDecision(5, decisionCanBacktrack[5]);
    			int LA5_0 = input.LA(1);

    			if (((LA5_0>='0' && LA5_0<='9')))
    			{
    				alt5 = 1;
    			}


    			} finally { DebugExitDecision(5); }
    			switch (alt5)
    			{
    			case 1:
    				DebugEnterAlt(1);
    				// Func.g:
    				{
    				DebugLocation(58, 15);
    				input.Consume();
    				state.failed=false;

    				}
    				break;

    			default:
    				if (cnt5 >= 1)
    					goto loop5;

    				if (state.backtracking>0) {state.failed=true; return;}
    				EarlyExitException eee5 = new EarlyExitException( 5, input );
    				DebugRecognitionException(eee5);
    				throw eee5;
    			}
    			cnt5++;
    		}
    		loop5:
    			;

    		} finally { DebugExitSubRule(5); }

    		DebugLocation(58, 22);
    		// Func.g:58:22: ( '.' ( DIGIT )+ )?
    		int alt7=2;
    		try { DebugEnterSubRule(7);
    		try { DebugEnterDecision(7, decisionCanBacktrack[7]);
    		int LA7_0 = input.LA(1);

    		if ((LA7_0=='.'))
    		{
    			alt7 = 1;
    		}
    		} finally { DebugExitDecision(7); }
    		switch (alt7)
    		{
    		case 1:
    			DebugEnterAlt(1);
    			// Func.g:58:23: '.' ( DIGIT )+
    			{
    			DebugLocation(58, 23);
    			Match('.'); if (state.failed) return;
    			DebugLocation(58, 27);
    			// Func.g:58:27: ( DIGIT )+
    			int cnt6=0;
    			try { DebugEnterSubRule(6);
    			while (true)
    			{
    				int alt6=2;
    				try { DebugEnterDecision(6, decisionCanBacktrack[6]);
    				int LA6_0 = input.LA(1);

    				if (((LA6_0>='0' && LA6_0<='9')))
    				{
    					alt6 = 1;
    				}


    				} finally { DebugExitDecision(6); }
    				switch (alt6)
    				{
    				case 1:
    					DebugEnterAlt(1);
    					// Func.g:
    					{
    					DebugLocation(58, 27);
    					input.Consume();
    					state.failed=false;

    					}
    					break;

    				default:
    					if (cnt6 >= 1)
    						goto loop6;

    					if (state.backtracking>0) {state.failed=true; return;}
    					EarlyExitException eee6 = new EarlyExitException( 6, input );
    					DebugRecognitionException(eee6);
    					throw eee6;
    				}
    				cnt6++;
    			}
    			loop6:
    				;

    			} finally { DebugExitSubRule(6); }


    			}
    			break;

    		}
    		} finally { DebugExitSubRule(7); }


    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("NUMBER", 21);
    		LeaveRule("NUMBER", 21);
    		LeaveRule_NUMBER();
        }
    }
    // $ANTLR end "NUMBER"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_BOOLEAN() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_BOOLEAN() {}

    // $ANTLR start "BOOLEAN"
    [GrammarRule("BOOLEAN")]
    private void mBOOLEAN()
    {
    	EnterRule_BOOLEAN();
    	EnterRule("BOOLEAN", 22);
    	TraceIn("BOOLEAN", 22);
    		try
    		{
    		int _type = BOOLEAN;
    		int _channel = DefaultTokenChannel;
    		// Func.g:61:2: ( 'true' | 'false' )
    		int alt8=2;
    		try { DebugEnterDecision(8, decisionCanBacktrack[8]);
    		int LA8_0 = input.LA(1);

    		if ((LA8_0=='t'))
    		{
    			alt8 = 1;
    		}
    		else if ((LA8_0=='f'))
    		{
    			alt8 = 2;
    		}
    		else
    		{
    			if (state.backtracking>0) {state.failed=true; return;}
    			NoViableAltException nvae = new NoViableAltException("", 8, 0, input);
    			DebugRecognitionException(nvae);
    			throw nvae;
    		}
    		} finally { DebugExitDecision(8); }
    		switch (alt8)
    		{
    		case 1:
    			DebugEnterAlt(1);
    			// Func.g:61:4: 'true'
    			{
    			DebugLocation(61, 4);
    			Match("true"); if (state.failed) return;


    			}
    			break;
    		case 2:
    			DebugEnterAlt(2);
    			// Func.g:62:4: 'false'
    			{
    			DebugLocation(62, 4);
    			Match("false"); if (state.failed) return;


    			}
    			break;

    		}
    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("BOOLEAN", 22);
    		LeaveRule("BOOLEAN", 22);
    		LeaveRule_BOOLEAN();
        }
    }
    // $ANTLR end "BOOLEAN"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_STRING() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_STRING() {}

    // $ANTLR start "STRING"
    [GrammarRule("STRING")]
    private void mSTRING()
    {
    	EnterRule_STRING();
    	EnterRule("STRING", 23);
    	TraceIn("STRING", 23);
    		try
    		{
    		int _type = STRING;
    		int _channel = DefaultTokenChannel;
    		int c = 0;

    		 System.Text.StringBuilder b = new System.Text.StringBuilder(); 
    		// Func.g:67:2: ( '\"' ( '\\\\' '\"' |c=~ ( '\"' ) )* '\"' )
    		DebugEnterAlt(1);
    		// Func.g:67:4: '\"' ( '\\\\' '\"' |c=~ ( '\"' ) )* '\"'
    		{
    		DebugLocation(67, 4);
    		Match('\"'); if (state.failed) return;
    		DebugLocation(68, 3);
    		// Func.g:68:3: ( '\\\\' '\"' |c=~ ( '\"' ) )*
    		try { DebugEnterSubRule(9);
    		while (true)
    		{
    			int alt9=3;
    			try { DebugEnterDecision(9, decisionCanBacktrack[9]);
    			int LA9_0 = input.LA(1);

    			if ((LA9_0=='\\'))
    			{
    				int LA9_2 = input.LA(2);

    				if ((LA9_2=='\"'))
    				{
    					int LA9_4 = input.LA(3);

    					if (((LA9_4>='\u0000' && LA9_4<='\uFFFF')))
    					{
    						alt9 = 1;
    					}

    					else
    					{
    						alt9 = 2;
    					}


    				}
    				else if (((LA9_2>='\u0000' && LA9_2<='!')||(LA9_2>='#' && LA9_2<='\uFFFF')))
    				{
    					alt9 = 2;
    				}


    			}
    			else if (((LA9_0>='\u0000' && LA9_0<='!')||(LA9_0>='#' && LA9_0<='[')||(LA9_0>=']' && LA9_0<='\uFFFF')))
    			{
    				alt9 = 2;
    			}


    			} finally { DebugExitDecision(9); }
    			switch ( alt9 )
    			{
    			case 1:
    				DebugEnterAlt(1);
    				// Func.g:68:5: '\\\\' '\"'
    				{
    				DebugLocation(68, 5);
    				Match('\\'); if (state.failed) return;
    				DebugLocation(68, 10);
    				Match('\"'); if (state.failed) return;
    				DebugLocation(68, 16);
    				if (state.backtracking == 0)
    				{
    					 b.Append('"');
    				}

    				}
    				break;
    			case 2:
    				DebugEnterAlt(2);
    				// Func.g:69:5: c=~ ( '\"' )
    				{
    				DebugLocation(69, 6);
    				c= input.LA(1);
    				input.Consume();
    				state.failed=false;
    				DebugLocation(69, 16);
    				if (state.backtracking == 0)
    				{
    					 b.Append((char)c);
    				}

    				}
    				break;

    			default:
    				goto loop9;
    			}
    		}

    		loop9:
    			;

    		} finally { DebugExitSubRule(9); }

    		DebugLocation(71, 3);
    		Match('\"'); if (state.failed) return;
    		DebugLocation(72, 3);
    		if (state.backtracking == 0)
    		{
    			 Text = b.ToString(); 
    		}

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("STRING", 23);
    		LeaveRule("STRING", 23);
    		LeaveRule_STRING();
        }
    }
    // $ANTLR end "STRING"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_DATE() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_DATE() {}

    // $ANTLR start "DATE"
    [GrammarRule("DATE")]
    private void mDATE()
    {
    	EnterRule_DATE();
    	EnterRule("DATE", 24);
    	TraceIn("DATE", 24);
    		try
    		{
    		int _type = DATE;
    		int _channel = DefaultTokenChannel;
    		// Func.g:75:6: ( DATE_FRAG ( ( ' ' TIME_FRAG )=> ' ' TIME_FRAG )? )
    		DebugEnterAlt(1);
    		// Func.g:75:8: DATE_FRAG ( ( ' ' TIME_FRAG )=> ' ' TIME_FRAG )?
    		{
    		DebugLocation(75, 8);
    		mDATE_FRAG(); if (state.failed) return;
    		DebugLocation(75, 18);
    		// Func.g:75:18: ( ( ' ' TIME_FRAG )=> ' ' TIME_FRAG )?
    		int alt10=2;
    		try { DebugEnterSubRule(10);
    		try { DebugEnterDecision(10, decisionCanBacktrack[10]);
    		int LA10_0 = input.LA(1);

    		if ((LA10_0==' ') && (EvaluatePredicate(synpred1_Func_fragment)))
    		{
    			alt10 = 1;
    		}
    		} finally { DebugExitDecision(10); }
    		switch (alt10)
    		{
    		case 1:
    			DebugEnterAlt(1);
    			// Func.g:75:19: ( ' ' TIME_FRAG )=> ' ' TIME_FRAG
    			{
    			DebugLocation(75, 38);
    			Match(' '); if (state.failed) return;
    			DebugLocation(75, 42);
    			mTIME_FRAG(); if (state.failed) return;
    			DebugLocation(75, 52);
    			if (state.backtracking == 0)
    			{
    				_type=DATETIME;
    			}

    			}
    			break;

    		}
    		} finally { DebugExitSubRule(10); }


    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("DATE", 24);
    		LeaveRule("DATE", 24);
    		LeaveRule_DATE();
        }
    }
    // $ANTLR end "DATE"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_TIME() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_TIME() {}

    // $ANTLR start "TIME"
    [GrammarRule("TIME")]
    private void mTIME()
    {
    	EnterRule_TIME();
    	EnterRule("TIME", 25);
    	TraceIn("TIME", 25);
    		try
    		{
    		int _type = TIME;
    		int _channel = DefaultTokenChannel;
    		// Func.g:76:6: ( TIME_FRAG )
    		DebugEnterAlt(1);
    		// Func.g:76:8: TIME_FRAG
    		{
    		DebugLocation(76, 8);
    		mTIME_FRAG(); if (state.failed) return;

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("TIME", 25);
    		LeaveRule("TIME", 25);
    		LeaveRule_TIME();
        }
    }
    // $ANTLR end "TIME"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_VAR() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_VAR() {}

    // $ANTLR start "VAR"
    [GrammarRule("VAR")]
    private void mVAR()
    {
    	EnterRule_VAR();
    	EnterRule("VAR", 26);
    	TraceIn("VAR", 26);
    		try
    		{
    		int _type = VAR;
    		int _channel = DefaultTokenChannel;
    		// Func.g:78:5: ( '$' PATH ( ( OPEN_PAR )=>)? )
    		DebugEnterAlt(1);
    		// Func.g:78:7: '$' PATH ( ( OPEN_PAR )=>)?
    		{
    		DebugLocation(78, 7);
    		Match('$'); if (state.failed) return;
    		DebugLocation(78, 11);
    		mPATH(); if (state.failed) return;
    		DebugLocation(78, 16);
    		// Func.g:78:16: ( ( OPEN_PAR )=>)?
    		int alt11=2;
    		try { DebugEnterSubRule(11);
    		try { DebugEnterDecision(11, decisionCanBacktrack[11]);
    		int LA11_0 = input.LA(1);

    		if ((EvaluatePredicate(synpred2_Func_fragment)))
    		{
    			alt11 = 1;
    		}
    		} finally { DebugExitDecision(11); }
    		switch (alt11)
    		{
    		case 1:
    			DebugEnterAlt(1);
    			// Func.g:78:17: ( OPEN_PAR )=>
    			{
    			DebugLocation(78, 31);
    			if (state.backtracking == 0)
    			{
    				_type=METHOD;
    			}

    			}
    			break;

    		}
    		} finally { DebugExitSubRule(11); }


    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("VAR", 26);
    		LeaveRule("VAR", 26);
    		LeaveRule_VAR();
        }
    }
    // $ANTLR end "VAR"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_FUNC() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_FUNC() {}

    // $ANTLR start "FUNC"
    [GrammarRule("FUNC")]
    private void mFUNC()
    {
    	EnterRule_FUNC();
    	EnterRule("FUNC", 27);
    	TraceIn("FUNC", 27);
    		try
    		{
    		int _type = FUNC;
    		int _channel = DefaultTokenChannel;
    		// Func.g:79:6: ( PATH )
    		DebugEnterAlt(1);
    		// Func.g:79:8: PATH
    		{
    		DebugLocation(79, 8);
    		mPATH(); if (state.failed) return;

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("FUNC", 27);
    		LeaveRule("FUNC", 27);
    		LeaveRule_FUNC();
        }
    }
    // $ANTLR end "FUNC"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_WS() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_WS() {}

    // $ANTLR start "WS"
    [GrammarRule("WS")]
    private void mWS()
    {
    	EnterRule_WS();
    	EnterRule("WS", 28);
    	TraceIn("WS", 28);
    		try
    		{
    		int _type = WS;
    		int _channel = DefaultTokenChannel;
    		// Func.g:81:4: ( ( ' ' | '\\t' | '\\n' | '\\r' | '\\f' )+ )
    		DebugEnterAlt(1);
    		// Func.g:81:6: ( ' ' | '\\t' | '\\n' | '\\r' | '\\f' )+
    		{
    		DebugLocation(81, 6);
    		// Func.g:81:6: ( ' ' | '\\t' | '\\n' | '\\r' | '\\f' )+
    		int cnt12=0;
    		try { DebugEnterSubRule(12);
    		while (true)
    		{
    			int alt12=2;
    			try { DebugEnterDecision(12, decisionCanBacktrack[12]);
    			int LA12_0 = input.LA(1);

    			if (((LA12_0>='\t' && LA12_0<='\n')||(LA12_0>='\f' && LA12_0<='\r')||LA12_0==' '))
    			{
    				alt12 = 1;
    			}


    			} finally { DebugExitDecision(12); }
    			switch (alt12)
    			{
    			case 1:
    				DebugEnterAlt(1);
    				// Func.g:
    				{
    				DebugLocation(81, 6);
    				input.Consume();
    				state.failed=false;

    				}
    				break;

    			default:
    				if (cnt12 >= 1)
    					goto loop12;

    				if (state.backtracking>0) {state.failed=true; return;}
    				EarlyExitException eee12 = new EarlyExitException( 12, input );
    				DebugRecognitionException(eee12);
    				throw eee12;
    			}
    			cnt12++;
    		}
    		loop12:
    			;

    		} finally { DebugExitSubRule(12); }

    		DebugLocation(81, 41);
    		if (state.backtracking == 0)
    		{
    			_channel = Hidden;
    		}

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("WS", 28);
    		LeaveRule("WS", 28);
    		LeaveRule_WS();
        }
    }
    // $ANTLR end "WS"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_COMMENT() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_COMMENT() {}

    // $ANTLR start "COMMENT"
    [GrammarRule("COMMENT")]
    private void mCOMMENT()
    {
    	EnterRule_COMMENT();
    	EnterRule("COMMENT", 29);
    	TraceIn("COMMENT", 29);
    		try
    		{
    		int _type = COMMENT;
    		int _channel = DefaultTokenChannel;
    		// Func.g:83:9: ( '//' ( . )* ( '\\n' | '\\r' ) )
    		DebugEnterAlt(1);
    		// Func.g:83:11: '//' ( . )* ( '\\n' | '\\r' )
    		{
    		DebugLocation(83, 11);
    		Match("//"); if (state.failed) return;

    		DebugLocation(83, 16);
    		// Func.g:83:16: ( . )*
    		try { DebugEnterSubRule(13);
    		while (true)
    		{
    			int alt13=2;
    			try { DebugEnterDecision(13, decisionCanBacktrack[13]);
    			int LA13_0 = input.LA(1);

    			if ((LA13_0=='\n'||LA13_0=='\r'))
    			{
    				alt13 = 2;
    			}
    			else if (((LA13_0>='\u0000' && LA13_0<='\t')||(LA13_0>='\u000B' && LA13_0<='\f')||(LA13_0>='\u000E' && LA13_0<='\uFFFF')))
    			{
    				alt13 = 1;
    			}


    			} finally { DebugExitDecision(13); }
    			switch ( alt13 )
    			{
    			case 1:
    				DebugEnterAlt(1);
    				// Func.g:83:16: .
    				{
    				DebugLocation(83, 16);
    				MatchAny(); if (state.failed) return;

    				}
    				break;

    			default:
    				goto loop13;
    			}
    		}

    		loop13:
    			;

    		} finally { DebugExitSubRule(13); }

    		DebugLocation(83, 19);
    		if (input.LA(1)=='\n'||input.LA(1)=='\r')
    		{
    			input.Consume();
    		state.failed=false;
    		}
    		else
    		{
    			if (state.backtracking>0) {state.failed=true; return;}
    			MismatchedSetException mse = new MismatchedSetException(null,input);
    			DebugRecognitionException(mse);
    			Recover(mse);
    			throw mse;
    		}

    		DebugLocation(83, 31);
    		if (state.backtracking == 0)
    		{
    			_channel = Hidden;
    		}

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("COMMENT", 29);
    		LeaveRule("COMMENT", 29);
    		LeaveRule_COMMENT();
        }
    }
    // $ANTLR end "COMMENT"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_MULTILINE_COMMENT() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_MULTILINE_COMMENT() {}

    // $ANTLR start "MULTILINE_COMMENT"
    [GrammarRule("MULTILINE_COMMENT")]
    private void mMULTILINE_COMMENT()
    {
    	EnterRule_MULTILINE_COMMENT();
    	EnterRule("MULTILINE_COMMENT", 30);
    	TraceIn("MULTILINE_COMMENT", 30);
    		try
    		{
    		int _type = MULTILINE_COMMENT;
    		int _channel = DefaultTokenChannel;
    		// Func.g:84:19: ( '/*' ( . )* '*/' )
    		DebugEnterAlt(1);
    		// Func.g:84:21: '/*' ( . )* '*/'
    		{
    		DebugLocation(84, 21);
    		Match("/*"); if (state.failed) return;

    		DebugLocation(84, 26);
    		// Func.g:84:26: ( . )*
    		try { DebugEnterSubRule(14);
    		while (true)
    		{
    			int alt14=2;
    			try { DebugEnterDecision(14, decisionCanBacktrack[14]);
    			int LA14_0 = input.LA(1);

    			if ((LA14_0=='*'))
    			{
    				int LA14_1 = input.LA(2);

    				if ((LA14_1=='/'))
    				{
    					alt14 = 2;
    				}
    				else if (((LA14_1>='\u0000' && LA14_1<='.')||(LA14_1>='0' && LA14_1<='\uFFFF')))
    				{
    					alt14 = 1;
    				}


    			}
    			else if (((LA14_0>='\u0000' && LA14_0<=')')||(LA14_0>='+' && LA14_0<='\uFFFF')))
    			{
    				alt14 = 1;
    			}


    			} finally { DebugExitDecision(14); }
    			switch ( alt14 )
    			{
    			case 1:
    				DebugEnterAlt(1);
    				// Func.g:84:26: .
    				{
    				DebugLocation(84, 26);
    				MatchAny(); if (state.failed) return;

    				}
    				break;

    			default:
    				goto loop14;
    			}
    		}

    		loop14:
    			;

    		} finally { DebugExitSubRule(14); }

    		DebugLocation(84, 29);
    		Match("*/"); if (state.failed) return;

    		DebugLocation(84, 34);
    		if (state.backtracking == 0)
    		{
    			_channel = Hidden;
    		}

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("MULTILINE_COMMENT", 30);
    		LeaveRule("MULTILINE_COMMENT", 30);
    		LeaveRule_MULTILINE_COMMENT();
        }
    }
    // $ANTLR end "MULTILINE_COMMENT"

    public override void mTokens()
    {
    	// Func.g:1:8: ( DOT | COMMA | SEMICOL | OPEN_PAR | CLOSE_PAR | NUMBER | BOOLEAN | STRING | DATE | TIME | VAR | FUNC | WS | COMMENT | MULTILINE_COMMENT )
    	int alt15=15;
    	try { DebugEnterDecision(15, decisionCanBacktrack[15]);
    	switch (input.LA(1))
    	{
    	case '.':
    		{
    		alt15 = 1;
    		}
    		break;
    	case ',':
    		{
    		alt15 = 2;
    		}
    		break;
    	case ';':
    		{
    		alt15 = 3;
    		}
    		break;
    	case '(':
    		{
    		alt15 = 4;
    		}
    		break;
    	case ')':
    		{
    		alt15 = 5;
    		}
    		break;
    	case '-':
    		{
    		alt15 = 6;
    		}
    		break;
    	case '0':
    	case '1':
    	case '2':
    	case '3':
    	case '4':
    	case '5':
    	case '6':
    	case '7':
    	case '8':
    	case '9':
    		{
    		int LA15_7 = input.LA(2);

    		if (((LA15_7>='0' && LA15_7<='9')))
    		{
    			switch (input.LA(3))
    			{
    			case '0':
    			case '1':
    			case '2':
    			case '3':
    			case '4':
    			case '5':
    			case '6':
    			case '7':
    			case '8':
    			case '9':
    				{
    				int LA15_20 = input.LA(4);

    				if (((LA15_20>='0' && LA15_20<='9')))
    				{
    					int LA15_24 = input.LA(5);

    					if ((LA15_24=='-'))
    					{
    						alt15 = 9;
    					}
    					else
    					{
    						alt15 = 6;
    					}
    				}
    				else
    				{
    					alt15 = 6;
    				}
    				}
    				break;
    			case ':':
    				{
    				alt15 = 10;
    				}
    				break;
    			default:
    				alt15=6;
    				break;

    			}

    		}
    		else
    		{
    			alt15 = 6;
    		}
    		}
    		break;
    	case 't':
    		{
    		int LA15_8 = input.LA(2);

    		if ((LA15_8=='r'))
    		{
    			int LA15_16 = input.LA(3);

    			if ((LA15_16=='u'))
    			{
    				int LA15_22 = input.LA(4);

    				if ((LA15_22=='e'))
    				{
    					int LA15_25 = input.LA(5);

    					if ((LA15_25=='.'||(LA15_25>='0' && LA15_25<='9')||(LA15_25>='A' && LA15_25<='Z')||(LA15_25>='a' && LA15_25<='z')))
    					{
    						alt15 = 12;
    					}
    					else
    					{
    						alt15 = 7;
    					}
    				}
    				else
    				{
    					alt15 = 12;
    				}
    			}
    			else
    			{
    				alt15 = 12;
    			}
    		}
    		else
    		{
    			alt15 = 12;
    		}
    		}
    		break;
    	case 'f':
    		{
    		int LA15_9 = input.LA(2);

    		if ((LA15_9=='a'))
    		{
    			int LA15_17 = input.LA(3);

    			if ((LA15_17=='l'))
    			{
    				int LA15_23 = input.LA(4);

    				if ((LA15_23=='s'))
    				{
    					int LA15_26 = input.LA(5);

    					if ((LA15_26=='e'))
    					{
    						int LA15_29 = input.LA(6);

    						if ((LA15_29=='.'||(LA15_29>='0' && LA15_29<='9')||(LA15_29>='A' && LA15_29<='Z')||(LA15_29>='a' && LA15_29<='z')))
    						{
    							alt15 = 12;
    						}
    						else
    						{
    							alt15 = 7;
    						}
    					}
    					else
    					{
    						alt15 = 12;
    					}
    				}
    				else
    				{
    					alt15 = 12;
    				}
    			}
    			else
    			{
    				alt15 = 12;
    			}
    		}
    		else
    		{
    			alt15 = 12;
    		}
    		}
    		break;
    	case '\"':
    		{
    		alt15 = 8;
    		}
    		break;
    	case '$':
    		{
    		alt15 = 11;
    		}
    		break;
    	case 'A':
    	case 'B':
    	case 'C':
    	case 'D':
    	case 'E':
    	case 'F':
    	case 'G':
    	case 'H':
    	case 'I':
    	case 'J':
    	case 'K':
    	case 'L':
    	case 'M':
    	case 'N':
    	case 'O':
    	case 'P':
    	case 'Q':
    	case 'R':
    	case 'S':
    	case 'T':
    	case 'U':
    	case 'V':
    	case 'W':
    	case 'X':
    	case 'Y':
    	case 'Z':
    	case 'a':
    	case 'b':
    	case 'c':
    	case 'd':
    	case 'e':
    	case 'g':
    	case 'h':
    	case 'i':
    	case 'j':
    	case 'k':
    	case 'l':
    	case 'm':
    	case 'n':
    	case 'o':
    	case 'p':
    	case 'q':
    	case 'r':
    	case 's':
    	case 'u':
    	case 'v':
    	case 'w':
    	case 'x':
    	case 'y':
    	case 'z':
    		{
    		alt15 = 12;
    		}
    		break;
    	case '\t':
    	case '\n':
    	case '\f':
    	case '\r':
    	case ' ':
    		{
    		alt15 = 13;
    		}
    		break;
    	case '/':
    		{
    		int LA15_14 = input.LA(2);

    		if ((LA15_14=='/'))
    		{
    			alt15 = 14;
    		}
    		else if ((LA15_14=='*'))
    		{
    			alt15 = 15;
    		}
    		else
    		{
    			if (state.backtracking>0) {state.failed=true; return;}
    			NoViableAltException nvae = new NoViableAltException("", 15, 14, input);
    			DebugRecognitionException(nvae);
    			throw nvae;
    		}
    		}
    		break;
    	default:
    		{
    			if (state.backtracking>0) {state.failed=true; return;}
    			NoViableAltException nvae = new NoViableAltException("", 15, 0, input);
    			DebugRecognitionException(nvae);
    			throw nvae;
    		}
    	}

    	} finally { DebugExitDecision(15); }
    	switch (alt15)
    	{
    	case 1:
    		DebugEnterAlt(1);
    		// Func.g:1:10: DOT
    		{
    		DebugLocation(1, 10);
    		mDOT(); if (state.failed) return;

    		}
    		break;
    	case 2:
    		DebugEnterAlt(2);
    		// Func.g:1:14: COMMA
    		{
    		DebugLocation(1, 14);
    		mCOMMA(); if (state.failed) return;

    		}
    		break;
    	case 3:
    		DebugEnterAlt(3);
    		// Func.g:1:20: SEMICOL
    		{
    		DebugLocation(1, 20);
    		mSEMICOL(); if (state.failed) return;

    		}
    		break;
    	case 4:
    		DebugEnterAlt(4);
    		// Func.g:1:28: OPEN_PAR
    		{
    		DebugLocation(1, 28);
    		mOPEN_PAR(); if (state.failed) return;

    		}
    		break;
    	case 5:
    		DebugEnterAlt(5);
    		// Func.g:1:37: CLOSE_PAR
    		{
    		DebugLocation(1, 37);
    		mCLOSE_PAR(); if (state.failed) return;

    		}
    		break;
    	case 6:
    		DebugEnterAlt(6);
    		// Func.g:1:47: NUMBER
    		{
    		DebugLocation(1, 47);
    		mNUMBER(); if (state.failed) return;

    		}
    		break;
    	case 7:
    		DebugEnterAlt(7);
    		// Func.g:1:54: BOOLEAN
    		{
    		DebugLocation(1, 54);
    		mBOOLEAN(); if (state.failed) return;

    		}
    		break;
    	case 8:
    		DebugEnterAlt(8);
    		// Func.g:1:62: STRING
    		{
    		DebugLocation(1, 62);
    		mSTRING(); if (state.failed) return;

    		}
    		break;
    	case 9:
    		DebugEnterAlt(9);
    		// Func.g:1:69: DATE
    		{
    		DebugLocation(1, 69);
    		mDATE(); if (state.failed) return;

    		}
    		break;
    	case 10:
    		DebugEnterAlt(10);
    		// Func.g:1:74: TIME
    		{
    		DebugLocation(1, 74);
    		mTIME(); if (state.failed) return;

    		}
    		break;
    	case 11:
    		DebugEnterAlt(11);
    		// Func.g:1:79: VAR
    		{
    		DebugLocation(1, 79);
    		mVAR(); if (state.failed) return;

    		}
    		break;
    	case 12:
    		DebugEnterAlt(12);
    		// Func.g:1:83: FUNC
    		{
    		DebugLocation(1, 83);
    		mFUNC(); if (state.failed) return;

    		}
    		break;
    	case 13:
    		DebugEnterAlt(13);
    		// Func.g:1:88: WS
    		{
    		DebugLocation(1, 88);
    		mWS(); if (state.failed) return;

    		}
    		break;
    	case 14:
    		DebugEnterAlt(14);
    		// Func.g:1:91: COMMENT
    		{
    		DebugLocation(1, 91);
    		mCOMMENT(); if (state.failed) return;

    		}
    		break;
    	case 15:
    		DebugEnterAlt(15);
    		// Func.g:1:99: MULTILINE_COMMENT
    		{
    		DebugLocation(1, 99);
    		mMULTILINE_COMMENT(); if (state.failed) return;

    		}
    		break;

    	}

    }
    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_synpred1_Func_fragment() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_synpred1_Func_fragment() {}

    // $ANTLR start synpred1_Func
    public void synpred1_Func_fragment()
    {
    	EnterRule_synpred1_Func_fragment();
    	EnterRule("synpred1_Func_fragment", 32);
    	TraceIn("synpred1_Func_fragment", 32);
    	try
    	{
    		// Func.g:75:19: ( ' ' TIME_FRAG )
    		DebugEnterAlt(1);
    		// Func.g:75:20: ' ' TIME_FRAG
    		{
    		DebugLocation(75, 20);
    		Match(' '); if (state.failed) return;
    		DebugLocation(75, 24);
    		mTIME_FRAG(); if (state.failed) return;

    		}

    	}
    	finally
    	{
    		TraceOut("synpred1_Func_fragment", 32);
    		LeaveRule("synpred1_Func_fragment", 32);
    		LeaveRule_synpred1_Func_fragment();
    	}
    }
    // $ANTLR end synpred1_Func
    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_synpred2_Func_fragment() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_synpred2_Func_fragment() {}

    // $ANTLR start synpred2_Func
    public void synpred2_Func_fragment()
    {
    	EnterRule_synpred2_Func_fragment();
    	EnterRule("synpred2_Func_fragment", 33);
    	TraceIn("synpred2_Func_fragment", 33);
    	try
    	{
    		// Func.g:78:17: ( OPEN_PAR )
    		DebugEnterAlt(1);
    		// Func.g:
    		{
    		DebugLocation(78, 17);
    		if (input.LA(1)=='(')
    		{
    			input.Consume();
    		state.failed=false;
    		}
    		else
    		{
    			if (state.backtracking>0) {state.failed=true; return;}
    			MismatchedSetException mse = new MismatchedSetException(null,input);
    			DebugRecognitionException(mse);
    			Recover(mse);
    			throw mse;
    		}


    		}

    	}
    	finally
    	{
    		TraceOut("synpred2_Func_fragment", 33);
    		LeaveRule("synpred2_Func_fragment", 33);
    		LeaveRule_synpred2_Func_fragment();
    	}
    }
    // $ANTLR end synpred2_Func

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA

	protected override void InitDFAs()
	{
		base.InitDFAs();
	}

 
	#endregion

}
